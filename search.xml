<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[破除 Margin 的黑魔法]]></title>
    <url>%2F2019%2F01%2F09%2Fmargin%2F</url>
    <content type="text"><![CDATA[Margin 真是个神奇的属性，使用过程中总能给我们带来各种惊喜。这不，今天又掉进了他的大坑！我给margin-top设置的负值总是不生效。越是着急用他的时候越是罢工，出现各种异常表现。拖延症晚期的我也终于忍无可忍，决心今天一定要彻底破除margin的黑魔法~ 先从基础的开始吧，逐步的深入，希望通过这次机会我们能彻底驯服这只桀骜不驯的小兽。 一、margin 基础margin 是一个设置盒子模型外边距的属性，其值的大小不会像 padding 那样对元素本身的尺寸造成影响。margin 可以设置的类型有以下四种（如表 1）： 表1：margin 取值类型 值 描述 auto 浏览器计算外边距 length 规定以具体单位计的外边距值，比如像素、厘米等。默认值是 0px % 规定基于父元素的宽度的百分比的外边距 inherit 规定应该从父元素继承外边距 需要注意以下两点： margin 值设置 % 时都是相对于元素的宽度计算的 margin 的默认值是 0，所以后面在使用 auto 时一定要手动设置 二、margin 异常场景汇总我最喜欢 margin-left 属性啦，它是真的乖，在任何场景下均无异常表现~但是其他方向表现如何呢，下面我们通过DEMO1进行实验，最终我对 margin 的各种情况验证并整理出表 2（可能不全，欢迎补充~） 表 2 结论的前提条件有下面几点：1.margin-top主要针对盒子中的第一个元素实验;2.margin-right、margin-bottom主要针对盒子中最后一个元素实验；3.「子」——子元素、「父」——父元素盒子；结论主要针对的是子元素的各种表现。 表2：margin 在不同场景下的表现 「子」Display「子」Margin「子」取值符号「父」定宽高「父」inline-block「子」表现「父」block「子」表现blockmargin-top+Y正常合并N正常合并-Y正常合并N正常合并margin-bottom+Y失效失效N正常合并-Y失效失效N正常合并margin-left+Y正常正常N正常正常-Y正常正常N正常正常margin-right+Y失效失效N正常失效-Y失效失效N正常失效inlinemargin-top+Y失效失效N失效失效-Y失效失效N失效失效margin-bottom+Y失效失效N失效失效-Y失效失效N失效失效margin-left+Y正常正常N正常正常-Y正常正常N正常正常margin-right+Y失效失效N正常失效-Y失效失效N正常失效inline-blockmargin-top+Y正常正常N正常正常-Y失效失效N失效失效margin-bottom+Y失效失效N正常正常-Y失效失效N正常正常margin-left+Y正常正常N正常正常-Y正常正常N正常正常margin-right+Y失效失效N正常失效-Y失效失效N正常失效 表 2 中的异常表现，后面会给出相应的解决方案 三、margin: auto 剖析margin: auto 是为了填充空闲尺寸而设计的。听着有些抽象，具体怎么填充的呢？我们继续探索~ margin: auto 的填充规则 规则一：两侧均为 auto 时，平分剩余空间 规则二：一侧定值，一侧 auto 时，auto 为剩余空间大小 margin: auto 的水平布局正因为margin: auto 两条填充规则的存在，使得块级元素实现了类似于行间元素text-aligin水平布局的特性 水平居中：使用“规则一”实现水平居中，这点我们再熟悉不过了，不再赘述。 水平居右：使用“规则二”实现水平居右，这点却经常会被我们忽视掉，快来看下DEMO2的实现 没错，我们通过设置margin-left:auto 实现了水平居右，这样一来 float:right 也可以休息片刻啦~ margin: auto 的垂直布局垂直布局？？？在我的印象中貌似实现不了垂直布局，DEMO3也验证了这一点：DEMO3 只实现了水平居中，未实现垂直居中。为什么没实现垂直布局呢？想弄明白这一点，就要对“空闲尺寸”的“自动填充”做进一步的理解了。 margin: auto触发的前提需要特别注意： 水平触发：当width设为auto时，宽度能自动填充满容器 垂直触发：当height设为auto时，高度能自动填充满容器 DEMO3 中：当 .in 设置width:auto后可以自动填充为 .out 的宽度 400px，满足对应方向的自动填充规则；但 .in 设置height:auto后却不能自动填充为 .out 的高度 300px，未能满足对应方向的自动填充规则。所以只实现了水平方向的居中，不能实现垂直方向的居中。 那如果我们一定要实现垂直方向居中（IE8+）又该如何做呢？ 经典三步曲：绝对定位 + 50%的 top 值 + height 一半的负值 新思路：绝对定位 + top:0 + bottom:0 + 垂直方向 margin:auto 因为当设置了绝对定位+top:0+bottom:0 后，即使将高度设置为 auto，依然能自动填充满屏高，所以满足 margin:auto 在垂直方向的触发条件^_^ 下面DEMO4展示了水平垂直居中的终极实现，这才应该是居中的正确打开方式。 四、margin 合并现象根据表 2 的实验结果，我们抽离出 margin 合并的情况再做详细梳理。 注：不考虑 writing-mode 的影响，我们这里所提的 margin 主要指垂直方向上的合并~ 父子合并异常表现： 父元素与第一个子元素的 margin-top 的合并 表 2 中：块级block「父元素」与「子元素」的 margin-top 正负值均与父元素发生合并 父元素与最后一个子元素的 margin-bottom 的合并： 表 2 中：块级block+未定高「父元素」与「子元素」的 margin-bottom 正负值均与父元素发生合并 margin-top 合并的解决方案： 父元素触发 BFC 父元素设置padding-top值（非 0） 父元素设置border-top的值 首个子元素前添加内联元素（分隔异常父子） margin-bottom 合并的解决方案： 父元素触发 BFC 父元素设置padding-bottom值（非 0） 父元素设置border-bottom的值 最后一个子元素后添加内联元素（分隔异常父子） 触发 BFC 最常用的方案是添加下面属性：1overflow: hidden; 父子合并解决方案的实质：通过一定手段强行分隔开异常父子，避免其直接接触，如padding、border、其他内联元素等 相邻兄弟元素合并此种现象对我们的布局影响不大，甚至有时这种合并会更方便我们的布局；一定要处理这种合并的话，迫使某一元素触发 BFC 即可解决~ 触发 BFC 最常用的方案同上添加：1overflow: hidden; 空块级元素合并这种情形我们遇到的就更少啦，这种机制的存在本意就是为了防止有一些多余的空标签未删除对布局造成影响。实际开发中多余空标签的存在是不规范的，直接删除就好!要强行保留空标签并解决合并问题的话，方法也是类似： 设置垂直方向padding的值（非 0） 设置垂直方向border的值 空标签中添加内容（直接添加 space 无效，用&amp;nbsp;代替） 五、margin 无效场景解析margin 无效场景总结根据表 2 的实验结果，我们抽离出 margin 无效的情况再做详细梳理。 行间inline元素的垂直 margin 均无效 行块inline-block元素的 margin-top 负值无效 定高容器的「子元素」的 margin-bottom 均无效 定宽容器/块级block未定宽容器的「子元素」的 margin-right 均无效 发生 margin 合并时，margin 垂直方向值小于合并后值时设置无效 非表 2 中表现出的无效现象的补充： 表格布局中的&lt;tr&gt;、&lt;td&gt;、table-cell、table-row 的 margin 无效 绝对定位元素非定位方向的 margin 无效 margin 无效场景解决方案针对表 2 无效场景出现的对应顺序给出如下解决方案： 行间inline元素设置为行块inline-block元素 行块inline-block元素设置 vertical-align: !baseline 非默认值（这里需要对 vertical-align做进一步深入） 容器不定高 容器设置为行块inline-block元素不定宽 解决margin合并问题 六、margin 常用场景 垂直水平居中布局DEMO4 两栏自适应布局DEMO5 注意margin-right生效的前提是：盒子为行块inline-block元素不定宽 两端对齐布局DEMO6 两栏等高布局DEMO7 此处“两栏等高布局”实现的缺点：1.没有底部边框，需手动添加（无需边框的场景比较方便）2.父元素overflow:hidden对子元素有一定的局限性（子元素定位到容器之外的场景不适用）3.影响锚点定位 正是这些不足的存在督促我们继续探索 =&gt; 可进一步总结其他实现“两栏等高布局”的方案（后期补充~） 今天的总结就到这里，自己梳理的基础上希望也能给大家带来些帮助。发现问题欢迎随时指出哟^_^ 七、参考资料 CSS 世界 —— 张鑫旭]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谁还没遇上“层叠上下文”呢]]></title>
    <url>%2F2018%2F09%2F10%2FStackingContext%2F</url>
    <content type="text"><![CDATA[一晃时间走了好远，又一年教师节了，在此祝所有老师教师节快乐！言归正传，为何提笔写此文呢？前两天在项目中给某个节点A设置 fixed 定位后出现了一个神奇的现象：无论我怎么设置其子节点B的层级，B总是会被A之后出现的任意带有层级的元素节点遮挡。我仿佛发现了新大陆一般惊奇，平日里对待熟悉的事物我总能做到恰到好处的蜻蜓点水，终于掉坑里了吧(囧)。于是乎，我决定今天要彻底弄懂层叠上下文（Stacking Context）。 还是先来看一下我遇到的问题吧~分别用chrome/firefox和IE打开DEMO1 哇~为什么IE上的表现和我们的预期一致，而 chrome/firefox 上却出现了异常呢？如果你也跟我一样好奇，那咱们就快点开始这次旅行吧~ 文中所有 IE 浏览器除特殊标明包含 IE7 外 均指 IE7 以上 一、层叠界的术语 Z轴：眼睛垂直于屏幕的一条虚拟的轴线 层叠上下文(Stacking Context)：表示元素在z轴上的层叠水平（html的三维概念） 层叠顺序(Stacking Order)：表示同一层叠上下文中的元素在z轴上的显示顺序 重要的事说三遍：所有层叠水平的比较都是以同一层叠上下文为基础的哟~同一层叠上下文为基础的哟~同一层叠上下文~ 二、层叠准则（前提：同一层叠上下文中做比较） 谁大谁上：非同一层叠水平时，水平高的在上面 后来居上：同一层叠水平时，后出现的在上面 三、层叠上下文的特性 层叠上下文的层叠水平要比普通元素高 层叠上下文可以嵌套：内部层叠上下文及其所有子元素均受制于外部的层叠上下文 每个层叠上下文和兄弟元素独立：当进行层叠变化或渲染的时候，只需考虑后代元素 每个层叠上下文自成体系：当元素发生层叠的时候，整个元素被认为在父层叠上下文的层叠顺序中 层叠上下文可以阻断元素的混合模式 四、层叠上下文的创建 天生派(根元素)：页面的根元素&lt;html&gt;天生具有层叠上下文 正统派(传统)：z-index为数值的定位/布局元素 IE7 定位/布局元素直接生成层叠上下文，因为IE7的z-index默认值就是0 扩招派(新秀)：CSS3 属性产生的层叠上下文 正统派层叠上下文创建 position: relative/absolute定位： z-index: !auto 创建 position: fixed定位： 「IE 内核的浏览器」z-index: !auto 创建 非「IE 内核的浏览器」直接创建（这就是 DEMO1 中异常现象产生的根源） position: sticky定位时 ？？？ sticky定位根据当前定位状态综合1，2两种情况 扩招派层叠上下文创建12345678910display:flex|inline-flex 弹性布局的元素：其”子元素“z-index != auto 创建元素的 opacity: !1元素的 transform: !none元素的 perspective != none // 透视效果元素的 filter: !none元素的 mix-blend-mode: !normal // 元素和白色背景混合，IE 不支持元素的 isolation: isolate // 阻隔混合模式元素的 will-change 属性值为 transform... // 增强页面渲染性能元素的 -webkit-overflow-scrolling: touch...... 层叠的表现可以看DEMO2 五、层叠顺序（Stacking Order）顾名思义，层叠顺序即元素在 Z 轴上的显示顺序。参照了张鑫旭对层叠顺序的图解，加之自己理解后，重新绘制了同一层叠上下文前提下的9级层叠顺序图，如下：DEMO3 DEMO3 是我对9级层叠顺序图进行的校验，如过大家发现存在什么问题可以随时联系我~ 思考两个问题 为什么内联元素（第6级）的层叠顺序比浮动元素（第5级）和块状元素（第4级）高？ 因为最初的最初我们所做的所有工作都是为展示图文信息做准备的，后来的诸多变化也未曾脱离这个源头 为什么定位元素会在普通元素之上展示？ 从图中可见定位元素跑到了第7级水平，高于普通元素 看图划重点啦： 当父级元素未生成自己的层叠上下文时，只需给z-index设置为负值即可实现元素的隐藏； 单纯从层叠水平来看，z-index的血统比其他方式生成层叠上下文的血统更纯正些； 因为z-index除了设置为auto/0（与其他层叠上下文同级）外，还可以显性的设置大于 0 的值 当transform: translateZ(&gt;0)出现后，z-index再想超越其层级就有些难度啦； 由上图可见transform: translateZ(&gt;0)在最高级了 虽有难度，但依然可以超越。只需给非body祖先元素添加overflow:hidden样式z-index就能重拾老大的称号~ 这是因为当给非body祖先元素添加了overflow:hidden后，transform便失去了其独特的魔法，此时的它乖乖地回到了第7级水平。 DEMO3给.bg-box 添加 overflow: hidden;可以验证一下第四点 六、改变层叠顺序不产生层叠上下文的前提下：(1) 调整DOM结构 后来居上准则 (2) 添加非z-index相关的属性 block、float、inline、inline-block、定位… 产生层叠上下文的前提下：(1) z-index问鼎天下 z-index设置层级须在定位元素position:!static或父元素弹性布局display:flex时生效，其值越大层叠水平越高； 非IE7的定位元素默认添加z-index:auto属性；DEMO4 现象：我们给 fixed 的相邻兄弟元素添加了 position: relative 后再滚动页面，发现 fixed 元素被遮住了！！！原因：同时设置定位后，元素均处于层叠顺序的第7级，处于同一层叠水平上，加之“后来居上”准则得此结果。 IE7的定位元素默认添加z-index:0属性，直接创建层叠上下文； z-index:auto与z-index:0在层叠顺序上均属于第7级，但在层叠上下文的产生上差异很大； position:fixed在非IE浏览器中会直接生成层叠上下文，无需显性设置z-index为数值； (2) translateZ逐鹿中原 transform 可生成新的层叠上下文 现象：下拉刷新的logo设置translateY偏移量后，结束刷新时logo没有被遮住；原因：transform 可生成新的层叠上下文。 通过设置 translateZ 的值来改变元素的层叠水平，其值越大，层级越高 translateZ 改变层级需要满足下列条件之一： 父元素中设置 transform-style: preserve-3d 当前元素设置 perspective 透视 (3) z-index与translateZ双剑合璧？？？当我们同时设置transform与z-index时，常会出现z-index失效的情况 我们该如何解决上述冲突呢？ 任意非body祖先元素设置overflow:hidden即可恢复和其他浏览器一样的渲染 以毒攻毒：同样可以使用 3D transform 变换 使劲提高 translateZ 的值（对于透视的情况，临界值并不好掌握-_-） 七、代码中的规范 非浮动元素：z-index “不犯2”准则 即对于非浮动元素 z-index 值的设置一般不超过 2 浮层元素：z-index “层级计数器” 对于浮层元素设置层级时，获取z-index最大值 / z-index默认值(习惯设置为9) 重新解释 DEMO1：非IE浏览器中，父元素设置 position:fixed 生成了层叠上下文；此层叠上下文的产生破坏了”同一层叠上下文“中比较层叠水平的基础，导致子元素所有的层级设置都受到父级层叠上下文的限制；最终造成的错觉是子元素的所有层级设置都失效了~ 八、参考文献 深入理解CSS中的层叠上下文和层叠顺序 z-index和transform,你真的了解吗？]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 年终总结]]></title>
    <url>%2F2018%2F01%2F18%2Ffirst%2F</url>
    <content type="text"><![CDATA[2018 就这样悄悄地的来了，是我忽略了太多的征兆吗，现在才感觉到它的气息，亏欠了 2017 的那个句点，是时候该画上了。2017，特别又特别的一年。这一年的北京微露清纯，少了雾霾的困扰，呈现出更加优雅的姿态；这一年的我稍显庞杂，没了学校的庇护，流露出略微复杂的心情；这一年的北京异常寒冷，这一年的我尤为忙碌；奈何此去无雪，向来经年有“学”。没控制住，文艺病又犯病了，那通俗点吧，这一年也许成长的不太明显，但我知道这是必经的旅行。 2017 回眸一笑17 年，我的既定目标是：在项目中提升自身的能力，努力脱掉前端小白的称号，最好能够折腾出一些有趣的东西。接近尾声了，只能说还算顺利的完成了前半段的计划——在项目中提升自己，至于后半段路——有意义的东西还没见踪影，需要继续加油啦。 17 年的工作情况： web 端项目：年初参与了组内第一个使用 vue 开发的 web 端项目。当时的我只是纯粹的写写业务，对于接口文档、项目配置、路由跳转等并未做深入的研究。之后 web 端项目接触的也越来越少。 H5 项目：3/4 的时间都在做 H5 应用，独立承担的 H5 应用大概有七个。 初期：使用 vue1 进行研发。对于技术，慢慢的由不熟悉到熟悉，经过一两个项目的洗礼后开始独立承担项目。 后期：随着 vue2 发布并日趋成熟，开始尝试使用 vue2 进行开发，vue2 项目换用了组内开发的组件库，很遗憾自己没有参与到组件的研发过程中去 :( 其他：穿插着切图、网站研发等其他任务 17 年的学习成果：这一年主要还是在开发过程中成长，遇到问题查阅文档，逛社区、论坛，或者同小伙伴交流，寻找思路。业余时间太少，总结做的还不到位，只能展示出项目中用到的技术了。 技术 优劣分析 掌握程度 切图 Html5、Css3、JS、Jquery… Css3 掌握的稍微好一些 ★★★★★ 网站研发 Html、Css、JS、Jquery、Freemarker、Java… Java 仅做了解 ★★★★☆ vue1 vue、vue-router、vue-resource、webpack、ES6… 熟练掌握 vue1，掌握 webpack、ES6 ★★★★☆ vue2 vue、vuex、vue-router、webpack、ES6… 熟练掌握 vue2，掌握 webpack、ES6 ★★★★☆ 17 年的生活状态：有一群志同道合的小伙伴，闲暇之余能聚在一起聊聊技术、谈谈理想，很开心、很珍惜。曾一度嚷嚷着要成立一个翻译小分队，专门翻译感觉不错的外文文献来着，最终搁浅了吧（囧），新的一年希望还能搭上我们的“翻译号”，真的扬帆去流浪哟！ 有几个爱念叨却很仗义的闺蜜，有一个默默给与温暖与支持的伴侣，有一间面积很大的屋子（虽然是租的），感觉再养一只小萨摩生活就完美了。 回首向来萧瑟处，归去，也无风雨也无晴。 哈哈，苏轼乱入一下，确实很喜欢这种态度。马不停蹄的工作了一年，进步还是有的，但少了总结与深入学习的时间，收获跟预期还有些许差距，需要继续努力啦。 2018 翘首以待首先想说，不管工作多忙，都要给自己预留时间做好总结，这是需要一定的技术支持和抗压能力的。能在拓宽广度的同时挖掘事物的深度，让一切变得通透明了，这样才能给自己更大的提升空间。其次呢，更要学会抽离自己，超出工作本身去做一些令自己欣喜的事情。比如学习之余写写博文，比如让我们的“翻译号”再次扬帆，比如在 github 上做一些有趣的东西，比如静下心来练练书法……只有自己的眼光变得足够开阔了，才能装得下更美好的风景。 希望有一天我的脑袋能变得像“哆啦A梦”的万能口袋那样，什么新奇美好的东西都装得下，作一程序媛如此，我也就满意啦！ 打个小广告，这是我养的一只哆啦A梦哟，想见它吗，快点点看!]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
</search>
