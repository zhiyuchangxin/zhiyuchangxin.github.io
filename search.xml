<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法设计思想——完结篇]]></title>
    <url>%2Farticles%2Farithmetic-three%2Findex.html</url>
    <content type="text"><![CDATA[设计思想总是太抽象，这里没有整理的很好（囧）。但既然说了要做三次总结，要说到做到，这里先做个标记，待后面有深入的思考后再重新整理。对算法设计思想有深入思考的同学可以暂时忽略这篇文章~在学习的过程中需重点关注以下几点：算法的特点、应用场景、时间复杂度、空间复杂度… 一、分而治之分而治之概念 分而治之是 算法设计 中的一种方法 它将一个问题 分 为多个和原问题相似的小问题，递归解决 小问题，在将结果 合 并以解决原来的问题 分而治之场景 场景一：归并排序 分：把数组从中间一分为二 解：递归地对两个子数组进行归并排序 合：合并有序子数组 场景二：快速排序 分：选基准，按基准把数组分成两个子数组 解：递归地对两个子数组进行快速排序 合：对基准和两个子数组进行合并 Leetcode 练习 [374] 猜数字大小 [226] 翻转二叉树 [100] 相同的树 [101] 对称二叉树 二、动态规划动态规划概念 动态规划是 算法设计 中的一种方法 它将一个问题分解为 相互重叠 的子问题，通过反复求解子问题，来解决原来的问题 动态规划场景 场景一：斐波那契数列 定义子问题：F(n) = F(n-1) + F(n-2) 反复执行：从2循环到n，执行上述公式 Leetcode 练习 [70] 爬楼梯 [198] 打家劫舍 [213] 打家劫舍2 [337] 打家劫舍3 [121] 买卖股票的最佳时机 [122] 买卖股票的最佳时机2 [714] 买卖股票的最佳时机含手续费 [309] 买卖股票的最佳时机含冷冻费 [123] 买卖股票的最佳时机3 [188] 买卖股票的最佳时机4 三、贪心算法贪心算法概念 贪心算法是 算法设计 中的一种方法 期盼通过每个阶段的 局部最优 选择，从而到达全局的最优 结果并 不一定是最优 贪心算法场景 场景一：零钱兑换 123456789// 得到了最优解输入：coins = [1, 2, 5], amount = 11输出：3解释：11 = 5 + 5 + 1// 未得到最优解输入：coins = [1, 3, 4], amount = 6输出：3解释：6 = 4 + 1 + 1 Leetcode 练习 [455] 分饼干 [122] 买卖股票的最佳时机 四、回溯算法回溯算法概念 回溯算法是 算法设计 中的一种方法 回溯算法是一种 渐进式 寻找并构建问题解决方案的策略 回溯算法会先选择一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决 回溯算法场景 有很多路这些路里，有死路，也有出路通常需要递归来模拟所有的路 场景一：全排列 用递归模拟出所有的情况 遇到包含重复元素的情况，就回溯 收集所有到达递归终点的情况，并返回 12345678910输入：[1, 2, 3]输出：[ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] Leetcode 练习 [46] 全排列 [78] 子集 技巧双指针需要枚举数组中的两个元素时，若随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法 未完待续]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 版排序与搜索——进阶篇]]></title>
    <url>%2Farticles%2Farithmetic-two%2Findex.html</url>
    <content type="text"><![CDATA[本文为算法系列学习的第二篇，希望通过这篇文章系统的对排序与搜索算法做一次梳理。文中仅总结了常见的几种排序与搜索算法，还有一些未总结到的，感兴趣的可以自己学习一下~在学习的过程中需重点关注以下几点：算法的特点、应用场景、时间复杂度、空间复杂度…准备好了吗，让我们开始吧~ 一、排序排序总览 排序方式 时间复杂度(平均) 时间复杂度(最坏) 时间复杂度(最好) 空间复杂度 稳定性 冒泡排序 O(n^2) O(n^2) O(n) O(1) 稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 插入排序 O(n^2) O(n^2) O(n) O(1) 稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 快速排序 O(nlogn) O(n^2) O(nlogn) O(nlogn) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 计数排序 O(n+k) O(n+k) O(n+k) O(n+k) 稳定 桶排序 O(n+k) O(n^2) O(n) O(n+k) 稳定 基数排序 O(n*K) O(n*K) O(n*K) O(n+K) 稳定 稳定性：如果a=b，排序前a在b前面，排序后a仍然在b前面，则称算法稳定，否则不稳定 1.1 冒泡排序基本思想 比较所有相邻元素，如果第一个比第二个大，则交换他们 一轮下来，可以保证最后一个数是最大的 执行 n-1 轮就可以完成排序 动画演示 代码实现123456789101112131415// 冒泡排序Array.prototype.bubbleSort = function() &#123; for (let i = 0; i &lt; this.length - 1; i++) &#123; for (let j = 0; j &lt; this.length - 1 - i; j++) &#123; if (this[j] &gt; this[j + 1]) &#123; let t = this[j] this[j] = this[j + 1] this[j + 1] = t &#125; &#125; &#125;&#125;const arr = [3, 5, 2, 6, 4, 1, 8]arr.bubbleSort() 复杂度分析 时间复杂度：O(n^2) 空间复杂度：O(1) 1.2 选择排序基本思想 找到数组中的最小值，选中他并将其放置在第一位 接着找到第二小的值，选中他并将其放置在第二位 以此类推，执行 n-1 轮 动画演示 代码实现12345678910111213141516171819// 选择排序Array.prototype.selectionSort = function() &#123; for (let i = 0; i &lt; this.length - 1; i++) &#123; let minIndex = i for (let j = i + 1; j &lt; this.length; j++) &#123; if (this[j] &lt; this[minIndex]) &#123; minIndex = j &#125; &#125; if (i !== minIndex) &#123; let t = this[i] this[i] = this[minIndex] this[minIndex] = t &#125; &#125;&#125;const arr = [3, 5, 2, 6, 4, 1, 8]arr.selectionSort() 复杂度分析 时间复杂度：O(n^2) 空间复杂度：O(1) 1.3 插入排序基本思想 从第二个数开始往前比 比他大就往后排 以此类推进行到最后一个数 动画演示 代码实现123456789101112131415// 插入排序Array.prototype.insertionSort = function() &#123; for (let i = 1; i &lt; this.length; i++) &#123; const temp = this[i] let j = i while (j &gt; 0 &amp;&amp; this[j - 1] &gt; temp) &#123; this[j] = this[j - 1] j-- &#125; this[j] = temp &#125;&#125;const arr = [3, 5, 2, 6, 4, 1, 8]arr.insertionSort() 复杂度分析 时间复杂度：O(n^2) 空间复杂度：O(1) 小型数组排序时：插入比冒泡、选择排序性能要好 1.4 归并排序基本思想 分：把数组劈成两半，再递归的对子数组进行“分”操作，直至分成一个个单独的数 合：把两个数合并为有序数组，再对有序数组进行合并，直至全部子数组合并为一个完整的数组 新建一个空数组 res，用于存放最终排序后的数组 比较两个有序数组的头部，较小者出队并推入 res 中 如果两个数组还有值，就重复第二步 动画演示 代码实现1234567891011121314151617181920212223242526272829303132// 归并排序Array.prototype.mergeSort = function() &#123; const rec = (arr) =&gt; &#123; // 分 if (arr.length &lt;= 1) return arr const mid = Math.floor(arr.length / 2) const left = arr.slice(0, mid) const right = arr.slice(mid, arr.length) const orderLeft = rec(left) const orderRight = rec(right) // 合 const res = [] while (orderLeft.length || orderRight.length) &#123; if (orderLeft.length &amp;&amp; orderRight.length) &#123; res.push(orderLeft[0] &lt; orderRight[0] ? orderLeft.shift() : orderRight.shift()) &#125; else if (orderLeft.length) &#123; res.push(orderLeft.shift()) &#125; else if (orderRight.length) &#123; res.push(orderRight.shift()) &#125; &#125; return res &#125; const res = rec(this) // 循环赋值 res.forEach((el, i) =&gt; this[i] = el)&#125;const arr = [3, 5, 2, 6, 4, 1, 8]arr.mergeSort() 复杂度分析 时间复杂度：O(n*logn) 【分】时间复杂度：O(logn) 【合】时间复杂度：O(n) 空间复杂度：O(n) 优缺点 归并排序始终能保证其 O(nlogn) 的性能（因此非常适合分类 大量 的输入） 归并排序是一个稳定的排序算法 在归并操作期间需要额外的 O(n) 的存储 ==「火狐浏览器」使用「归并算法」实现 sort== 1.5 快速排序基本思想 分区：从数组中任意选择一个基准，所有比基准小的元素放在基准的前面，比基准大的元素放在基准的后面 递归：递归的对基准前后的子数组进行分区 动画演示 代码实现12345678910111213141516171819202122// 快速排序Array.prototype.quickSort = function() &#123; const rec = (arr) =&gt; &#123; if (arr.length &lt;= 1) return arr const left = [] // 左区 const right = [] // 右区 const mid = arr[0] // 基准 for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; mid) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return [...rec(left), mid, ...rec(right)] &#125; const res = rec(this) res.forEach((el, i) =&gt; this[i] = el)&#125;const arr = [3, 5, 2, 6, 4, 1, 8]arr.quickSort() 复杂度分析 时间复杂度：O(n*logn) 【递归】时间复杂度：O(logn) 【分区】时间复杂度：O(n) 空间复杂度：==? O(n*logn)== ==「老版 chrome」== 使用 ==「快速排序」== 实现 sort==「新版 chrome」==【1】当数组 ==length &lt;= 10== 时使用 ==「插入排序」== 实现 sort【2】当数组 ==length &gt; 10== 时使用 ==「快速排序」== 实现 sort ➡️ 随机快速排序 除了执行分区算法之外，与快速排序相同 随机选择 a[i..j] 之间的枢轴，而不是始终选择 a[i]（或 a[i..j]之间的任何其他固定索引） … 1.6 堆排序基本思想 构建最小堆 挨个将堆顶出堆，直至堆为空 动画演示 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 最小堆类class MinHeap &#123; constructor() &#123; this.heap = [] &#125; // 交换操作 swap(i1, i2) &#123; const t = this.heap[i1] this.heap[i1] = this.heap[i2] this.heap[i2] = t &#125; // 获取父节点索引 getPindex(i) &#123; return (i - 1) &gt;&gt; 1 &#125; // 获取左节点索引 getLindex(i) &#123; return 2 * i + 1 &#125; // 获取右节点索引 getRindex(i) &#123; return 2 * i + 2 &#125; // 上移操作 shiftUp(index) &#123; if (index === 0) return const pIndex = this.getPindex(index) if (this.heap[index] &lt; this.heap[pIndex]) &#123; this.swap(index, pIndex) this.shiftUp(pIndex) &#125; &#125; // 下移操作 shiftDown(index) &#123; if (index === this.heap.length - 1) return const lIndex = this.getLindex(index) const rIndex = this.getRindex(index) if (this.heap[index] &gt; this.heap[lIndex]) &#123; this.swap(index, lIndex) this.shiftDown(lIndex) &#125; if (this.heap[index] &gt; this.heap[rIndex]) &#123; this.swap(index, rIndex) this.shiftDown(rIndex) &#125; &#125; // 插入 // 1. 插入堆底（即数组尾部） // 2. 上移操作：将新堆底和他的父节点进行交换，直至父节点小于等于新堆底 // 时间复杂度：O(logk) k为堆的大小 insert(n) &#123; this.heap.push(n) this.shiftUp(this.heap.length - 1) &#125; // 删除 // 1. 数组尾部元素替换堆顶（直接删除堆顶会破坏堆的结构） // 2. 下移操作：将新堆顶和他的子节点进行交换，直到子节点大于等于新堆顶 // 时间复杂度：O(logk) k为堆的大小 pop() &#123; if (this.size() &gt; 1) &#123; this.heap[0] = this.heap.pop() this.shiftDown(0) &#125; else &#123; this.heap.pop() &#125; &#125; // 堆顶元素 peek() &#123; return this.heap[0] &#125; // 堆大小 size() &#123; return this.heap.length &#125;&#125;// 堆排序Array.prototype.heapSort = function() &#123; const minheap = new MinHeap() for (let i = 0; i &lt; this.length; i++) &#123; minheap.insert(this[i]) &#125; for (let i = 0; i &lt; this.length; i++) &#123; this[i] = minheap.peek() minheap.pop() &#125;&#125;const arr = [3, 5, 2, 6, 4, 1, 8]arr.heapSort() 复杂度分析 时间复杂度：O(n*logn) 空间复杂度：O(n) ==如何实现 O(1) ？== 二、搜索2.1 顺序搜索基本思想 遍历数组 若找到跟目标值相等的元素，则搜索结束返回其下标 若遍历结束仍未找到目标值，则搜索结束返回 -1 代码实现123456789101112// 顺序搜索Array.prototype.sequentialSearch = function(n) &#123; for (let i = 0; i &lt; this.length; i++) &#123; if (this[i] === n) &#123; return i &#125; &#125; return -1&#125;const arr = [3, 5, 2, 6, 4, 1, 8]arr.sequentialSearch(1) // 5 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 2.2 二分搜索基本思想 前提：数组 有序 从数组的 中间元素 开始搜索 若中间元素刚好 等于 目标值，则搜索结束返回其下标 若目标值 大于/小于 中间元素，则在 大于/小于 中间元素的那一半数组中继续搜索 代码实现1234567891011121314151617181920// 二分搜索Array.prototype.binarySearch = function(n) &#123; let low = 0 let high = this.length - 1 while (high &gt;= low) &#123; const mid = Math.floor((low + high) / 2) const el = this[mid] if (n === el) return mid if (n &gt; el) &#123; low = mid + 1 &#125; else &#123; high = mid - 1 &#125; &#125; return -1&#125;const arr = [3, 5, 2, 6, 4, 1, 8].sort() // [1,2,3,4,5,6,8]arr.binarySearch(3) // 2 复杂度分析 时间复杂度：O(logn) 空间复杂度：O(1) Leetcode 练习 [374] 猜数字大小 [69] x的平方根 2.3 其他搜索（详情待补充） 插值查找 斐波那契查找 树表查找 分块查找 哈希查找 …]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 版数据结构与算法——基础篇]]></title>
    <url>%2Farticles%2Farithmetic-one%2Findex.html</url>
    <content type="text"><![CDATA[本次系列学习，主要是从前端的视角出发，梳理前端与算法的结合点。常见知识点大致被拆分成下图展示的三个模块：数据结构、进阶算法、算法设计思想。本文为基础篇，主要学习第一部分——数据结构。在学习的过程中需重点关注以下几点：算法的特点、应用场景、时间复杂度、空间复杂度… 接下来，我们将按照下面的目录顺序依次展开： 栈 队列 链表 集合 字典 树 图 堆 准备工作：针对所列出的数据结构，我们再细分为有序数据结构、无序数据结构、复杂数据结构三组，由易到难渐进式的学习。 补齐概念： 时间复杂度：定性描述算法的运行时间 空间复杂度：算法在运行过程中临时占用存储空间大小的度量 一、有序数据结构有序数据结构主要包括以下三个： 栈 队列 链表 1.1 栈 栈是一个 后进先出 的数据结构 Js 中没有栈，但可以使用 Array 实现栈的所有功能 1234567891011121314151617181920212223class Stack &#123; constructor (arr) &#123; this.stack = arr || [] &#125; // 入栈 push (item) &#123; this.stack.push(item) &#125; // 出栈 pop () &#123; return this.stack.pop() &#125; // 获取栈顶元素 peek () &#123; return this.stack.length ? this.stack[this.stack.length - 1] : null &#125; // 判断栈是否为空 empty () &#123; return this.stack.length === 0 &#125;&#125; 栈的应用场景： 十进制转二进制 判断字符串的括号是否有效 函数调用堆栈 …… LeetCode 练习： [20] 有效的括号 [144] 二叉树的前序遍历 1.2 队列 队列是一个 先进先出 的数据结构 Js 中没有队列，但可以使用 Array 实现队列的所有功能 123456789101112131415161718192021class Queue &#123; constructor (arr) &#123; this.queue = arr || [] &#125; // 入队 push (item) &#123; this.queue.push(item) &#125; // 出队 shift () &#123; return this.queue.shift() &#125; // 获取队头元素 peek () &#123; return this.queue[0] || null &#125; // 判断队是否为空 empty () &#123; return this.queue.length === 0 &#125;&#125; 队列的应用场景： 计算最近请求次数 js 异步中的任务队列 应用场景拓展——任务队列： 简单概括 js 的事件循环与任务队列（不展开细讲） 如图所示： 1.当异步代码返回结果后会放到任务队列中 2.待调用栈中的代码执行完毕，js 引擎便会启动轮询机制 3.到任务队列中依次查找并放到调用栈中执行 LeetCode 练习： [933] 最近请求次数 1.3 链表 链表是多个元素组成的列表，元素存储不连续，用 next 指针连在一起 数组 VS 链表 数组：增删非首尾元素时，需要移动该元素之后的所有元素 链表：增删非首尾元素时，无需移动元素，只需更改 next 指向即可 Js 中没有链表，但可以使用 Object 模拟链表 123456789101112131415161718192021// js 模拟链表const a = &#123; val: 'a' &#125;const b = &#123; val: 'b' &#125;const c = &#123; val: 'c' &#125;a.next = bb.next = c// 遍历链表（重点）let p = awhile (p) &#123; console.log(p.val) p = p.next&#125;// 插入const d = &#123; val: 'd' &#125;b.next = dd.next = c// 删除b.next = c 链表的应用场景： js 中的原型链 获取 json 的节点值 …… 应用场景拓展——原型链： 原型链的本质是链表 原型链上的节点是各种原型对象 （eg: Function.prototype、Object.prototype…） 原型链通过 __proto__ 属性连接各种原型对象 特性1：如果 A 沿着原型链能找到 B.prototype，那么 A instanceof B 为 true 特性2：如果在 A 对象上没有找到 x 属性，那么会沿着原型链继续查找 12345678910111213// 特性1 练习：简述 instanceof 的原理，并用代码实现// 分析：遍历 A 的原型链，如果能找到 B.prototype 则返回 true，否则返回 falseconst instanceof = (A, B) =&gt; &#123; let p = A while (p) &#123; if (p === B.prototype) &#123; return true &#125; p = p.__proto__ &#125; return false&#125; 12345678910// 特性2 练习：const obj = &#123;&#125;Object.prototype.a = 'a'const func = function () &#123;&#125;Function.prototype.b = 'b'console.log(obj.a) // aconsole.log(obj.b) // undefinedconsole.log(func.a) // aconsole.log(func.b) // b 应用场景拓展——获取 json 节点值 123456789101112const data = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;, d: &#123; e: 2 &#125;&#125;const path = ['a', 'b', 'c']let p = datapath.forEach(el =&gt; &#123; p = p[el]&#125;)console.log(p) // 1 LeetCode 练习： [237] 删除链表中的节点：将被删除节点转移到下个节点 [206] 反转链表：1.双指针一前一后遍历链表；2.反转双指针 [2] 两数相加 [83] 删除排序链表中的重复元素 [141] 环形链表：一快一慢两个指针遍历链表，如果指针能够相逢，说明链表有环 [234] 回文链表 二、无序数据结构无序数据结构主要包括以下两个： 集合 字典 2.1 集合 集合是一种 无序且唯一 的数据结构 ES6 中有集合——Set 集合的常用操作：去重、判断某元素是否在集合中、求交集 12345678910111213141516171819202122232425262728const arr = [1, 1, 2, 2]const set = new Set(arr)const set2 = new Set([2, 3])// 增set.add(5)// 删set.delete(5)// 元素是否在集合中set.has(3) // true// 集合迭代// for (let item of set) console.log(item)// for (let item of set.keys()) console.log(item)// for (let item of set.values()) console.log(item)for (let [key, value] of set.entries()) console.log(key, value)// 集合求交集const set3 = new Set([...set].filter(el =&gt; set2.has(el)))// 集合求差集const set4 = new Set([...set].filter(el =&gt; !set2.has(el)))// 数组去重const arr2 = Array.from(new Set(arr))const arr3 = [...new Set(arr)] LeetCode 练习： [349] 两个数组的交集 2.2 字典 字典是一种以 键值对的形式存储唯一值 的数据结构 ES6 中有字典——Map 字典的常用操作：键值对的增、删、改、查 123456789101112131415161718const map = new Map()// 增map.set('a', 'aa')map.set('b', 'bb')// 删map.delete('b')// map.clear()// 改map.set('a', 'cc')// 查map.get('a') // 'aa'// 元素是否在字典中map.has('a') // true 思考：比较 Map 和 Object 频繁增删操作的性能 123456789101112131415161718192021222324252627282930313233343536373839// 不同循环体内测试const map = new Mapconst obj = &#123;&#125;// 对 Map 频繁进行增删const t11 = (new Date()).getTime()for (let i = 0; i &lt; 999999; i++) &#123; map.set(i, i)&#125;const t12 = (new Date()).getTime()console.log('Map增加时间：', t12 - t11) // 138const t21 = (new Date()).getTime()for (let i = 0; i &lt; 999999; i++) &#123; map.delete(i)&#125;const t22 = (new Date()).getTime()console.log('Map删除时间：', t22 - t21) // 123console.log('Map增删总时间：', t22 - t11) // 266// 对 Object 频繁进行增删const t31 = (new Date()).getTime()for (let i = 0; i &lt; 999999; i++) &#123; obj[i] = i&#125;const t32 = (new Date()).getTime()console.log('Object增加时间：', t32 - t31) // 44const t41 = (new Date()).getTime()for (let i = 0; i &lt; 999999; i++) &#123; delete obj[i]&#125;const t42 = (new Date()).getTime()console.log('Object删除时间：', t42 - t41) // 60console.log('Object增删总时间：', t42 - t31) // 104 12345678910111213141516171819202122// 同一循环体内测试const map = new Mapconst obj = &#123;&#125;// 对 Map 频繁进行增删const t1 = (new Date()).getTime()for (let i = 0; i &lt; 999999; i++) &#123; map.set(i, i) map.delete(i)&#125;const t2 = (new Date()).getTime()console.log('Map增删总时间：', t2 - t1) // 105// 对 Object 频繁进行增删const t3 = (new Date()).getTime()for (let i = 0; i &lt; 999999; i++) &#123; obj[i] = i delete obj[i]&#125;const t4 = (new Date()).getTime()console.log('Object增删总时间：', t4 - t3) // 285 结论：1.不同循环体内频繁进行增删操作，Object 性能优于 Map2.同一循环体内频繁进行增删操作，Map 性能优于 Object LeetCode 练习： [349] 两个数组的交集 [20] 有效的括号 [1] 两数之和 [3] 无重复字符串的最长子串 [76] 最小覆盖子串 三、复杂数据结构还剩下三个稍微高级一点的数据结构： 树 图 堆 3.1 树 树是一种 分层 数据的抽象模型 前端常见的树：DOM 树、级联选择、树形控件、Json… Js 中没有树，但可以使用 Object 和 Array 来构建树 树的常用操作： 深度优先遍历：尽可能深的搜索树的分支 广度优先遍历：先访问离根节点最近的节点 二叉树的先序遍历 二叉树的中序遍历 二叉树的后序遍历 树的 深度优先遍历 12345678910/** * 深度优先遍历步骤： * 1. 访问根节点 * 2. 对根节点的 children 挨个进行深度优先遍历 */const dfs = (root) =&gt; &#123; console.log(root.val) root.children.forEach(dfs)&#125; 1234567891011121314151617/** * 深度优先遍历应用场景：获取 json 节点值 */const json = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;, d: [1, 2]&#125;const dfs = (n, path) =&gt; &#123; console.log(n, path) Object.keys(n).forEach((k) =&gt; &#123; dfs(n[k], path.concat(k)) &#125;)&#125;dfs(json, []) 树的 广度优先遍历 12345678910111213141516/** * 广度优先遍历步骤： * 1. 新建一个队列，把根节点入队 * 2. 把对头出队并访问 * 3. 把对头的 children 挨个入队 * 4. 重复2、3步，直到队列为空 */const bfs = (root) =&gt; &#123; const q = [root] while (q.length) &#123; const data = q.shift() console.log(data.val) data.children.forEach(child =&gt; q.push(child)) &#125;&#125; 二叉树的 先序遍历 1234567891011121314151617181920212223242526/** * 先序遍历步骤： * 1. 访问根节点 * 2. 对根节点的左子树进行先序遍历 * 3. 对根节点的右子树进行先序遍历 */ // 递归版const preorder = (root) =&gt; &#123; if (!root) return console.log(root.val) preorder(root.left) preorder(root.right)&#125;// 非递归版const preorder2 = (root) =&gt; &#123; if (!root) return const stack = [root] while (stack.length) &#123; const n = stack.pop() console.log(n.val) n.right &amp;&amp; stack.push(n.right) n.left &amp;&amp; stack.push(n.left) &#125;&#125; 二叉树的 中序遍历 123456789101112131415161718192021222324252627282930/** * 中序遍历步骤： * 1. 对根节点的左子树进行中序遍历 * 2. 访问根节点 * 3. 对根节点的右子树进行中序遍历 */// 递归版const inorder = (root) =&gt; &#123; if (!root) return inorder(root.left) console.log(root.val) inorder(root.right)&#125;// 非递归版const inorder2 = (root) =&gt; &#123; if (!root) return const stack = [] let p = root while (stack.length || p) &#123; while (p) &#123; stack.push(p) p = p.left &#125; const n = stack.pop() console.log(n.val) p = n.right &#125;&#125; 二叉树的 后序遍历 12345678910111213141516171819202122232425262728293031/** * 后序遍历步骤： * 1. 对根节点的左子树进行后序遍历 * 2. 对根节点的右子树进行后序遍历 * 3. 访问根节点 */// 递归版const postorder = (root) =&gt; &#123; if (!root) return postorder(root.left) postorder(root.right) console.log(root.val)&#125;// 非递归版const postorder = (root) =&gt; &#123; if (!root) return const outstack = [] const stack = [root] while (stack.length) &#123; const n = stack.pop() outstack.push(n) n.left &amp;&amp; stack.push(n.left) n.right &amp;&amp; stack.push(n.right) &#125; while (outstack.length) &#123; const n = outstack.pop() console.log(n.val) &#125;&#125; LeetCode 练习： [104] 二叉树的最大深度 [111] 二叉树的最小深度 [102] 二叉树的层序遍历 [94] 二叉树的中序遍历 [112] 路径总和 3.2 图 图是 网络结构 的抽象模型，是一组由 边 连接的 节点 图可以表示任何二元关系 eg：道路、航班… Js 中没有图，但可以使用 Object 和 Array 来构建图 图的表示法：邻接矩阵、邻接表、关联矩阵… 图的常用操作： 深度优先遍历：尽可能深的搜索图的分支 广度优先遍历：先访问离根节点最近的节点 图的 深度优先遍历 1234567891011121314151617/** * 图的深度优先遍历: * 1. 访问根节点 * 1. 对根节点没访问过的相邻节点挨个进行深度优先遍历 */const visited = new Set()const dfs = (n) =&gt; &#123; console.log(n) visited.add(n) graph[n].forEach(el =&gt; &#123; if (!visited.has(el)) &#123; dfs(el) &#125; &#125;)&#125; 图的 广度优先遍历 123456789101112131415161718192021222324/** * 图的广度优先遍历 * 1. 新建一个队列，将根节点入队 * 2. 对头出队并访问 * 3. 将对头没有访问过的相邻节点挨个入队 * 4. 循环2，3步，直至队列为空 */const visited = new Set()const bfs = (n) =&gt; &#123; const q = [n] visited.add(n) while (q.length) &#123; const top = q.shift() console.log(top) graph[top].forEach(el =&gt; &#123; if (!visited.has(el)) &#123; q.push(el) visited.add(el) &#125; &#125;) &#125;&#125; LeetCode 练习： [65] 有效数字 [417] 太平洋大西洋水流问题、 [133] 克隆图 3.3 堆 堆是一种特殊的 完全二叉树 所有节点都 大于等于（最大堆） 或 小于等于（最小堆） 它的子节点 Js 中通常用 Array 表示堆 左侧子节点的位置：2 * index + 1 右侧子节点的位置：2 * index + 2 父节点的位置：(index - 1) / 2 堆的应用场景： 高效快速的找出 最大值 和 最小值 （时间复杂度O(1)） 查找第 K 个最大（最小）元素 js 实现最小堆类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class MinHeap &#123; constructor() &#123; this.heap = [] &#125; // 交换操作 swap(i1, i2) &#123; const t = this.heap[i1] this.heap[i1] = this.heap[i2] this.heap[i2] = t &#125; // 获取父节点索引 getPindex(i) &#123; return (i - 1) &gt;&gt; 1 &#125; // 获取左节点索引 getLindex(i) &#123; return 2 * i + 1 &#125; // 获取右节点索引 getRindex(i) &#123; return 2 * i + 2 &#125; // 上移操作 shiftUp(index) &#123; if (index === 0) return const pIndex = this.getPindex(index) if (this.heap[index] &lt; this.heap[pIndex]) &#123; this.swap(index, pIndex) this.shiftUp(pIndex) &#125; &#125; // 下移操作 shiftDown(index) &#123; if (index === this.heap.length - 1) return const lIndex = this.getLindex(index) const rIndex = this.getRindex(index) if (this.heap[index] &gt; this.heap[lIndex]) &#123; this.swap(index, lIndex) this.shiftDown(lIndex) &#125; if (this.heap[index] &gt; this.heap[rIndex]) &#123; this.swap(index, rIndex) this.shiftDown(rIndex) &#125; &#125; // 插入 // 1. 插入堆底（即数组尾部） // 2. 上移操作：将新堆底和他的父节点进行交换，直至父节点小于等于新堆底 // 时间复杂度：O(logk) k为堆的大小 insert(n) &#123; this.heap.push(n) this.shiftUp(this.heap.length - 1) &#125; // 删除 // 1. 数组尾部元素替换堆顶（直接删除堆顶会破坏堆的结构） // 2. 下移操作：将新堆顶和他的子节点进行交换，直到子节点大于等于新堆顶 // 时间复杂度：O(logk) k为堆的大小 pop() &#123; this.heap[0] = this.heap.pop() this.shiftDown(0) &#125; // 堆顶元素 peek() &#123; return this.heap[0] &#125; // 堆大小 size() &#123; return this.heap.length &#125;&#125; LeetCode 练习： [215] 数组中的第 K 个最大元素 [347] 前 K 个高频元素 [23] 合并 K 个排序链表 总结本次学习就到这里啦，虽然比较基础，但是不经常回顾还是容易忘的，有时间就多看看吧。下一章会跟大家一起学习一下排序与搜索算法。期待~]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关动画的思考与宏观总结]]></title>
    <url>%2Farticles%2Fanimation-all%2Findex.html</url>
    <content type="text"><![CDATA[前期曾细粒度的从多个角度对 web 动画做过一些研究，今天主要想从宏观的角度总结一下动画的实现以及目前主流的3D库。在愈来愈追求极致体验的今天，Web开发者已经不满足于2D效果的实现，而把目标放到了更加炫酷的3D效果上。 在Web3D百花齐放的今天，和大家简单探讨一下目前主流的3D库。 一、前期思考实现成本动画的实现需要综合考虑两个方面的实现成本： 前端技术实现 设计动画/模型实现 思考维度技术选型需要结合以下几个维度进行考量： 开发语言的支持 2D、3D、VR的支持 性能 应用广度 设计理念 商业化成熟案例 学习资源与技术支持能力 二、动画分类下面总结一下动画的分类（非官方总结，如有不同意见欢迎指出~） 类别 分类 技术方案 Js动画、css3动画、HTML5动画 交互类型 展示型动画、交互型动画 特殊效果 骨骼动画、粒子动画、差值动画… 维度 2D动画、拟3D动画、3D动画 技术方案分类： Js 动画：很多成熟的 js 动画库… css3 动画：transition、animation、Animate.css库… HTML5 动画：svg、canvas、webgl… 交互类型分类： 展示型动画:（只要动画开始，就无法控制动画的状态） gif图 css3 canvas canvas上绘制的图形自身不支持DOM事件，只有canvas标签自身支持DOM事件监听 对canvas容器的事件进行处理，实现相对应事件的监听及处理） svg（同 canvas） … 交互型动画: WebGL（WebGL在Android 4.4 Browser 不支持，可使用canvas优雅降级） 利用 JS 驱动的动画 … 特殊效果分类： 骨骼动画：多用于游戏、logo、彩蛋… 设计方案对比： 名称 介绍 导出格式 收费情况 其他 Dragonbones 白鹭时代退出的2D骨骼动画解决方案 支持JSON 免费 - Spine 针对游戏开发的2D骨骼动画编辑工具 支持JSON 收费 - 万彩骨骼大师 专门制作2D动画任务/角色的软件 不支持JSON 免费 限windows系统 粒子动画：canvas、Three.js… 维度分类： 2D 动画 拟3D动画：2D动画通过变换模拟简单3D效果 3D 动画：Three.js、Egret、Layabox… 三、动画实现方案 Engine 2D Render 3D Render JS TS 2D 性能 3D 性能 精简后体积 其他 Three.js No Yes Yes No None 10 100K JS 语言的 3D 库 Phaser Yes No Yes Yes - - - H5 游戏框架，引用 Pixi.js 渲染内核 Pixi.js Yes No Yes Yes 10 None - 依赖于 canvas 的 WebGL 2D渲染器 Egret Yes Yes Yes Yes 10 10 - 游戏解决方案 Layabox Yes Yes Yes Yes 10 10 300K - Hilo Yes No Yes No 5 None - - Cocos2d Yes No Yes No 7 None - - 展示型：Lottie1.官网：http://airbnb.io/lottie 2.优点：跨平台（iOS|Android|Web|RN|windows）、开源、文件较小、api较完备… 3.缺点： Bodymovin插件待完善，仍有部分AE效果无法成功导出 Lottie对json文件的支持待完善，仍有部分成功导出的json文件在移动端上无法很好的展现 交互支持不够友好 4.设计：AE + bodymovin 5.demo Svga1.官网：https://svga.io/ 2.优点：跨平台（iOS|Android|Web）兼容性好、开源、使用简单、性能卓越 3.缺点：动画方式唯一、交互支持不够友好 4.设计：AE | Animate(Flash) 5.demo 交互型：Three.js1.官网：https://threejs.org/ 2.JS 语言的 3D 库 3.设计：3Dsmax（3dMax）、blender、Sketchup、maya、unity… 4.3d动漫人物欣赏 5.Demo（3d模型、粒子化） Dragonbones1.官网：http://dragonbones.com/cn/index.html 2.概念：2D骨骼动画解决方案（面向设计师的动画创作平台；更少的美术成本，更生动的动画效果；多语言支持，一次制作，全平台发布） 3.预设动画欣赏 4.Demo（公鸡换装） 四、设计细节常见3d文件格式： 官方推荐使用格式：gltf（glb）粒子化3D模型效果总结： 建议模型：gltf/glb 注意点：模型不需要过于细节化，否则绘制粒子数量过大严重影响性能 骨骼动画总结（2D）： 建议编辑器：Dragonbones（龙骨） 缺陷：拟3D效果，有一定角度限制 补足：如需要展示更多角度，需设计出更多角度的贴图 五、参考 前端动画调研 3D探索——Web 3D哪家强 三维文件格式 abc, glTF, fbx, obj, dae, stl, 3ds, ply,… 3d模型下载的哪个网站好 白鹭引擎和layabox哪个好用，哪个技术更成熟]]></content>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破除 Margin 的黑魔法]]></title>
    <url>%2Farticles%2Fmargin%2Findex.html</url>
    <content type="text"><![CDATA[Margin 真是个神奇的属性，使用过程中总能给我们带来各种惊喜。这不，今天又掉进了他的大坑！我给margin-top设置的负值总是不生效。越是着急用他的时候越是罢工，出现各种异常表现。拖延症晚期的我也终于忍无可忍，决心今天一定要彻底破除margin的黑魔法~ 先从基础的开始吧，逐步的深入，希望通过这次机会我们能彻底驯服这只桀骜不驯的小兽。 Margin 基础margin 是一个设置盒子模型外边距的属性，其值的大小不会像 padding 那样对元素本身的尺寸造成影响。margin 可以设置的类型有以下四种（如表 1）： 表1：margin 取值类型 值 描述 auto 浏览器计算外边距 length 规定以具体单位计的外边距值，比如像素、厘米等。默认值是 0px % 规定基于父元素的宽度的百分比的外边距 inherit 规定应该从父元素继承外边距 需要注意以下两点： margin 值设置 % 时都是相对于元素的宽度计算的 margin 的默认值是 0，所以后面在使用 auto 时一定要手动设置 Margin 异常场景汇总我最喜欢margin-left属性啦，它是真的乖，在任何场景下均无异常表现~但是其他方向表现如何呢，下面我们通过DEMO1进行实验，最终我对 margin 的各种情况验证并整理出表 2（可能不全，欢迎补充~） 表 2 结论的前提条件有下面几点：1.margin-top主要针对盒子中的第一个元素实验;2.margin-right、margin-bottom主要针对盒子中最后一个元素实验；3.「子」——子元素、「父」——父元素盒子；结论主要针对的是子元素的各种表现。 表2：margin 在不同场景下的表现 「子」Display「子」Margin「子」取值符号「父」定宽高「父」inline-block「子」表现「父」block「子」表现blockmargin-top+Y正常合并N正常合并-Y正常合并N正常合并margin-bottom+Y失效失效N正常合并-Y失效失效N正常合并margin-left+Y正常正常N正常正常-Y正常正常N正常正常margin-right+Y失效失效N正常失效-Y失效失效N正常失效inlinemargin-top+Y失效失效N失效失效-Y失效失效N失效失效margin-bottom+Y失效失效N失效失效-Y失效失效N失效失效margin-left+Y正常正常N正常正常-Y正常正常N正常正常margin-right+Y失效失效N正常失效-Y失效失效N正常失效inline-blockmargin-top+Y正常正常N正常正常-Y失效失效N失效失效margin-bottom+Y失效失效N正常正常-Y失效失效N正常正常margin-left+Y正常正常N正常正常-Y正常正常N正常正常margin-right+Y失效失效N正常失效-Y失效失效N正常失效 表 2 中的异常表现，后面会给出相应的解决方案 Margin: auto 剖析margin: auto 是为了填充空闲尺寸而设计的。听着有些抽象，具体怎么填充的呢？我们继续探索~ margin: auto 的填充规则 规则一：两侧均为 auto 时，平分剩余空间 规则二：一侧定值，一侧 auto 时，auto 为剩余空间大小 margin: auto 的水平布局正因为margin: auto 两条填充规则的存在，使得块级元素实现了类似于行间元素text-aligin水平布局的特性 水平居中：使用“规则一”实现水平居中，这点我们再熟悉不过了，不再赘述。 水平居右：使用“规则二”实现水平居右，这点却经常会被我们忽视掉，快来看下DEMO2的实现 没错，我们通过设置margin-left:auto 实现了水平居右，这样一来 float:right 也可以休息片刻啦~ margin: auto 的垂直布局垂直布局？？？在我的印象中貌似实现不了垂直布局，DEMO3也验证了这一点：DEMO3 只实现了水平居中，未实现垂直居中。为什么没实现垂直布局呢？想弄明白这一点，就要对“空闲尺寸”的“自动填充”做进一步的理解了。 margin: auto触发的前提需要特别注意： 水平触发：当width设为auto时，宽度能自动填充满容器 垂直触发：当height设为auto时，高度能自动填充满容器 DEMO3 中：当 .in 设置width:auto后可以自动填充为 .out 的宽度 400px，满足对应方向的自动填充规则；但 .in 设置height:auto后却不能自动填充为 .out 的高度 300px，未能满足对应方向的自动填充规则。所以只实现了水平方向的居中，不能实现垂直方向的居中。 那如果我们一定要实现垂直方向居中（IE8+）又该如何做呢？ 经典三步曲：绝对定位 + 50%的 top 值 + height 一半的负值 新思路：绝对定位 + top:0 + bottom:0 + 垂直方向 margin:auto 因为当设置了绝对定位+top:0+bottom:0 后，即使将高度设置为 auto，依然能自动填充满屏高，所以满足 margin:auto 在垂直方向的触发条件^_^ 下面DEMO4展示了水平垂直居中的终极实现，这才应该是居中的正确打开方式。 Margin 合并现象根据表 2 的实验结果，我们抽离出 margin 合并的情况再做详细梳理。 注：不考虑 writing-mode 的影响，我们这里所提的 margin 主要指垂直方向上的合并~ 父子合并异常表现： 父元素与第一个子元素的 margin-top 的合并 表 2 中：块级block「父元素」与「子元素」的 margin-top 正负值均与父元素发生合并 父元素与最后一个子元素的 margin-bottom 的合并： 表 2 中：块级block+未定高「父元素」与「子元素」的 margin-bottom 正负值均与父元素发生合并 margin-top合并的解决方案： 父元素触发 BFC 父元素设置padding-top值（非 0） 父元素设置border-top的值 首个子元素前添加内联元素（分隔异常父子） margin-bottom合并的解决方案： 父元素触发 BFC 父元素设置padding-bottom值（非 0） 父元素设置border-bottom的值 最后一个子元素后添加内联元素（分隔异常父子） 触发 BFC 最常用的方案是添加下面属性：1overflow: hidden; 父子合并解决方案的实质：通过一定手段强行分隔开异常父子，避免其直接接触，如padding、border、其他内联元素等 相邻兄弟元素合并此种现象对我们的布局影响不大，甚至有时这种合并会更方便我们的布局；一定要处理这种合并的话，迫使某一元素触发 BFC 即可解决~ 触发 BFC 最常用的方案同上添加：1overflow: hidden; 空块级元素合并这种情形我们遇到的就更少啦，这种机制的存在本意就是为了防止有一些多余的空标签未删除对布局造成影响。实际开发中多余空标签的存在是不规范的，直接删除就好!要强行保留空标签并解决合并问题的话，方法也是类似： 设置垂直方向padding的值（非 0） 设置垂直方向border的值 空标签中添加内容（直接添加 space 无效，用&amp;nbsp;代替） Margin 无效场景解析margin 无效场景总结根据表 2 的实验结果，我们抽离出 margin 无效的情况再做详细梳理。 行间inline元素的垂直 margin 均无效 行块inline-block元素的 margin-top 负值无效 定高容器的「子元素」的 margin-bottom 均无效 定宽容器/块级block未定宽容器的「子元素」的 margin-right 均无效 发生 margin 合并时，margin 垂直方向值小于合并后值时设置无效 非表 2 中表现出的无效现象的补充： 表格布局中的&lt;tr&gt;、&lt;td&gt;、table-cell、table-row 的 margin 无效 绝对定位元素非定位方向的 margin 无效 margin 无效场景解决方案针对表 2 无效场景出现的对应顺序给出如下解决方案： 行间inline元素设置为行块inline-block元素 行块inline-block元素设置 vertical-align: !baseline 非默认值（这里需要对 vertical-align做进一步深入） 容器不定高 容器设置为行块inline-block元素不定宽 解决margin合并问题 Margin 常用场景 垂直水平居中布局DEMO4 两栏自适应布局DEMO5 注意margin-right生效的前提是：盒子为行块inline-block元素不定宽 两端对齐布局DEMO6 两栏等高布局DEMO7 此处“两栏等高布局”实现的缺点：1.没有底部边框，需手动添加（无需边框的场景比较方便）2.父元素overflow:hidden对子元素有一定的局限性（子元素定位到容器之外的场景不适用）3.影响锚点定位 正是这些不足的存在督促我们继续探索 =&gt; 可进一步总结其他实现“两栏等高布局”的方案（后期补充~） 今天的总结就到这里，自己梳理的基础上希望也能给大家带来些帮助。发现问题欢迎随时指出哟^_^ 参考资料 CSS 世界 —— 张鑫旭]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谁还没遇上“层叠上下文”呢]]></title>
    <url>%2Farticles%2FStackingContext%2Findex.html</url>
    <content type="text"><![CDATA[一晃时间走了好远，又一年教师节了，在此祝所有老师教师节快乐！言归正传，为何提笔写此文呢？前两天在项目中给某个节点A设置 fixed 定位后出现了一个神奇的现象：无论我怎么设置其子节点B的层级，B总是会被A之后出现的带有层级的元素节点遮挡。我仿佛发现了新大陆一般惊奇，平日里对待熟悉的事物我总能做到恰到好处的蜻蜓点水，终于掉坑里了吧(囧)。于是乎，我决定今天要彻底弄懂层叠上下文（Stacking Context）。 还是先来看一下我遇到的问题吧~分别用chrome/firefox和IE打开DEMO1 哇~为什么IE上的表现和我们的预期一致，而 chrome/firefox 上却出现了异常呢？如果你也跟我一样好奇，那咱们就快点开始这次旅行吧~ 文中所有 IE 浏览器除特殊标明包含 IE7 外 均指 IE7 以上 一、层叠界的术语 Z轴：眼睛垂直于屏幕的一条虚拟的轴线 层叠上下文(Stacking Context)：表示元素在z轴上的层叠水平（html的三维概念） 层叠顺序(Stacking Order)：表示同一层叠上下文中的元素在z轴上的显示顺序 重要的事说三遍：所有层叠水平的比较都是以同一层叠上下文为基础的哟~同一层叠上下文为基础的哟~同一层叠上下文~ 二、层叠准则（前提：同一层叠上下文中做比较） 谁大谁上：非同一层叠水平时，水平高的在上面 后来居上：同一层叠水平时，后出现的在上面 三、层叠上下文的特性 层叠上下文的层叠水平要比普通元素高 层叠上下文可以嵌套：内部层叠上下文及其所有子元素均受制于外部的层叠上下文 每个层叠上下文和兄弟元素独立：当进行层叠变化或渲染的时候，只需考虑后代元素 每个层叠上下文自成体系：当元素发生层叠的时候，整个元素被认为在父层叠上下文的层叠顺序中 层叠上下文可以阻断元素的混合模式 四、层叠上下文的创建 天生派(根元素)：页面的根元素&lt;html&gt;天生具有层叠上下文 正统派(传统)：z-index为数值的定位/布局元素 IE7 定位/布局元素直接生成层叠上下文，因为IE7的z-index默认值就是0 扩招派(新秀)：CSS3 属性产生的层叠上下文 正统派层叠上下文创建 position: relative/absolute定位： z-index: !auto 创建 position: fixed定位： 「IE 内核的浏览器」z-index: !auto 创建 非「IE 内核的浏览器」直接创建（这就是 DEMO1 中异常现象产生的根源） position: sticky定位时 ？？？ sticky定位根据当前定位状态综合1，2两种情况 扩招派层叠上下文创建12345678910display:flex|inline-flex 弹性布局的元素：其”子元素“z-index != auto 创建元素的 opacity: !1元素的 transform: !none元素的 perspective != none // 透视效果元素的 filter: !none元素的 mix-blend-mode: !normal // 元素和白色背景混合，IE 不支持元素的 isolation: isolate // 阻隔混合模式元素的 will-change 属性值为 transform... // 增强页面渲染性能元素的 -webkit-overflow-scrolling: touch...... 层叠的表现可以看DEMO2 五、层叠顺序（Stacking Order）顾名思义，层叠顺序即元素在 Z 轴上的显示顺序。参照了张鑫旭对层叠顺序的图解，加之自己理解后，重新绘制了同一层叠上下文前提下的9级层叠顺序图，如下：DEMO3 DEMO3 是我对9级层叠顺序图进行的校验，如过大家发现存在什么问题可以随时联系我~ 思考两个问题 为什么内联元素（第6级）的层叠顺序比浮动元素（第5级）和块状元素（第4级）高？ 因为最初的最初我们所做的所有工作都是为展示图文信息做准备的，后来的诸多变化也未曾脱离这个源头 为什么定位元素会在普通元素之上展示？ 从图中可见定位元素跑到了第7级水平，高于普通元素 看图划重点啦： 当父级元素未生成自己的层叠上下文时，只需给z-index设置为负值即可实现元素的隐藏； 单纯从层叠水平来看，z-index的血统比其他方式生成层叠上下文的血统更纯正些； 因为z-index除了设置为auto/0（与其他层叠上下文同级）外，还可以显性的设置大于 0 的值 当transform: translateZ(&gt;0)出现后，z-index再想超越其层级就有些难度啦； 由上图可见transform: translateZ(&gt;0)在最高级了 虽有难度，但依然可以超越。只需给非body祖先元素添加overflow:hidden样式z-index就能重拾老大的称号~ 这是因为当给非body祖先元素添加了overflow:hidden后，transform便失去了其独特的魔法，此时的它乖乖地回到了第7级水平。 DEMO3给.bg-box 添加 overflow: hidden;可以验证一下第四点 六、改变层叠顺序不产生层叠上下文的前提下：(1) 调整DOM结构 后来居上准则 (2) 添加非z-index相关的属性 block、float、inline、inline-block、定位… 产生层叠上下文的前提下：(1) z-index问鼎天下 z-index设置层级须在定位元素position:!static或父元素弹性布局display:flex时生效，其值越大层叠水平越高； 非IE7的定位元素默认添加z-index:auto属性；DEMO4 现象：我们给 fixed 的相邻兄弟元素添加了 position: relative 后再滚动页面，发现 fixed 元素被遮住了！！！原因：同时设置定位后，元素均处于层叠顺序的第7级，处于同一层叠水平上，加之“后来居上”准则得此结果。 IE7的定位元素默认添加z-index:0属性，直接创建层叠上下文； z-index:auto与z-index:0在层叠顺序上均属于第7级，但在层叠上下文的产生上差异很大； position:fixed在非IE浏览器中会直接生成层叠上下文，无需显性设置z-index为数值； (2) translateZ逐鹿中原 transform 可生成新的层叠上下文 现象：下拉刷新的logo设置translateY偏移量后，结束刷新时logo没有被遮住；原因：transform 可生成新的层叠上下文。 通过设置 translateZ 的值来改变元素的层叠水平，其值越大，层级越高 translateZ 改变层级需要满足下列条件之一： 父元素中设置 transform-style: preserve-3d 当前元素设置 perspective 透视 (3) z-index与translateZ双剑合璧？？？当我们同时设置transform与z-index时，常会出现z-index失效的情况 我们该如何解决上述冲突呢？ 任意非body祖先元素设置overflow:hidden即可恢复和其他浏览器一样的渲染 以毒攻毒：同样可以使用 3D transform 变换 使劲提高 translateZ 的值（对于透视的情况，临界值并不好掌握-_-） 七、代码中的规范 非浮动元素：z-index “不犯2”准则 即对于非浮动元素 z-index 值的设置一般不超过 2 浮层元素：z-index “层级计数器” 对于浮层元素设置层级时，获取z-index最大值 / z-index默认值(习惯设置为9) 重新解释 DEMO1：非IE浏览器中，父元素设置 position:fixed 生成了层叠上下文；此层叠上下文的产生破坏了”同一层叠上下文“中比较层叠水平的基础，导致子元素所有的层级设置都受到父级层叠上下文的限制；最终造成的错觉是子元素的所有层级设置都失效了~ 八、参考文献 深入理解CSS中的层叠上下文和层叠顺序 z-index和transform,你真的了解吗？]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 年终总结]]></title>
    <url>%2Farticles%2Ffirst%2Findex.html</url>
    <content type="text"><![CDATA[2018 就这样悄悄地的来了，是我忽略了太多的征兆吗，现在才感觉到它的气息，亏欠了 2017 的那个句点，是时候该画上了。2017，特别又特别的一年。这一年的北京微露清纯，少了雾霾的困扰，呈现出更加优雅的姿态；这一年的我稍显庞杂，没了学校的庇护，流露出略微复杂的心情；这一年的北京异常寒冷，这一年的我尤为忙碌；奈何此去无雪，向来经年有“学”。没控制住，文艺病又犯病了，那通俗点吧，这一年也许成长的不太明显，但我知道这是必经的旅行。 2017 回眸一笑17 年，我的既定目标是：在项目中提升自身的能力，努力脱掉前端小白的称号，最好能够折腾出一些有趣的东西。接近尾声了，只能说还算顺利的完成了前半段的计划——在项目中提升自己，至于后半段路——有意义的东西还没见踪影，需要继续加油啦。 17 年的工作情况： web 端项目：年初参与了组内第一个使用 vue 开发的 web 端项目。当时的我只是纯粹的写写业务，对于接口文档、项目配置、路由跳转等并未做深入的研究。之后 web 端项目接触的也越来越少。 H5 项目：3/4 的时间都在做 H5 应用，独立承担的 H5 应用大概有七个。 初期：使用 vue1 进行研发。对于技术，慢慢的由不熟悉到熟悉，经过一两个项目的洗礼后开始独立承担项目。 后期：随着 vue2 发布并日趋成熟，开始尝试使用 vue2 进行开发，vue2 项目换用了组内开发的组件库，很遗憾自己没有参与到组件的研发过程中去 :( 其他：穿插着切图、网站研发等其他任务 17 年的学习成果：这一年主要还是在开发过程中成长，遇到问题查阅文档，逛社区、论坛，或者同小伙伴交流，寻找思路。业余时间太少，总结做的还不到位，只能展示出项目中用到的技术了。 技术 优劣分析 掌握程度 切图 Html5、Css3、JS、Jquery… Css3 掌握的稍微好一些 ★★★★★ 网站研发 Html、Css、JS、Jquery、Freemarker、Java… Java 仅做了解 ★★★★☆ vue1 vue、vue-router、vue-resource、webpack、ES6… 熟练掌握 vue1，掌握 webpack、ES6 ★★★★☆ vue2 vue、vuex、vue-router、webpack、ES6… 熟练掌握 vue2，掌握 webpack、ES6 ★★★★☆ 17 年的生活状态：有一群志同道合的小伙伴，闲暇之余能聚在一起聊聊技术、谈谈理想，很开心、很珍惜。曾一度嚷嚷着要成立一个翻译小分队，专门翻译感觉不错的外文文献来着，最终搁浅了吧（囧），新的一年希望还能搭上我们的“翻译号”，真的扬帆去流浪哟！ 有几个爱念叨却很仗义的闺蜜，有一个默默给与温暖与支持的伴侣，有一间面积很大的屋子（虽然是租的），感觉再养一只小萨摩生活就完美了。 回首向来萧瑟处，归去，也无风雨也无晴。 哈哈，苏轼乱入一下，确实很喜欢这种态度。马不停蹄的工作了一年，进步还是有的，但少了总结与深入学习的时间，收获跟预期还有些许差距，需要继续努力啦。 2018 翘首以待首先想说，不管工作多忙，都要给自己预留时间做好总结，这是需要一定的技术支持和抗压能力的。能在拓宽广度的同时挖掘事物的深度，让一切变得通透明了，这样才能给自己更大的提升空间。其次呢，更要学会抽离自己，超出工作本身去做一些令自己欣喜的事情。比如学习之余写写博文，比如让我们的“翻译号”再次扬帆，比如在 github 上做一些有趣的东西，比如静下心来练练书法……只有自己的眼光变得足够开阔了，才能装得下更美好的风景。 希望有一天我的脑袋能变得像“哆啦A梦”的万能口袋那样，什么新奇美好的东西都装得下，作一程序媛如此，我也就满意啦！ 打个小广告，这是我养的一只哆啦A梦哟，想见它吗，快点点看!]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
</search>
