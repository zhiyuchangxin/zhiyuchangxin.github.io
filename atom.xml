<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>One Piece</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="//blog.zhiyuchangxin.cn/"/>
  <updated>2020-12-25T12:17:02.589Z</updated>
  <id>//blog.zhiyuchangxin.cn/</id>
  
  <author>
    <name>织语长心</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法设计思想——完结篇</title>
    <link href="//blog.zhiyuchangxin.cn/articles/arithmetic-three/index.html"/>
    <id>//blog.zhiyuchangxin.cn/articles/arithmetic-three/index.html</id>
    <published>2020-12-18T02:00:00.000Z</published>
    <updated>2020-12-25T12:17:02.589Z</updated>
    
    <content type="html"><![CDATA[<p>设计思想总是太抽象，这里没有整理的很好（囧）。<br>但既然说了要做三次总结，要说到做到，这里先做个标记，待后面有深入的思考后再重新整理。<br>对算法设计思想有深入思考的同学可以暂时忽略这篇文章~<br>在学习的过程中需重点关注以下几点：算法的特点、应用场景、时间复杂度、空间复杂度…  </p><a id="more"></a><h2 id="一、分而治之"><a href="#一、分而治之" class="headerlink" title="一、分而治之"></a>一、分而治之</h2><h3 id="分而治之概念"><a href="#分而治之概念" class="headerlink" title="分而治之概念"></a>分而治之概念</h3><ol><li><p>分而治之是 <strong>算法设计</strong> 中的一种方法</p></li><li><p>它将一个问题 <strong>分</strong> 为多个和原问题相似的小问题，<strong>递归解决</strong> 小问题，在将结果 <strong>合</strong> 并以解决原来的问题</p></li></ol><h3 id="分而治之场景"><a href="#分而治之场景" class="headerlink" title="分而治之场景"></a>分而治之场景</h3><ul><li>场景一：归并排序<ul><li>分：把数组从中间一分为二</li><li>解：递归地对两个子数组进行归并排序</li><li>合：合并有序子数组</li></ul></li><li>场景二：快速排序<ul><li>分：选基准，按基准把数组分成两个子数组</li><li>解：递归地对两个子数组进行快速排序</li><li>合：对基准和两个子数组进行合并</li></ul></li></ul><h3 id="Leetcode-练习"><a href="#Leetcode-练习" class="headerlink" title="Leetcode 练习"></a>Leetcode 练习</h3><ul><li>[374] 猜数字大小</li><li>[226] 翻转二叉树</li><li>[100] 相同的树</li><li>[101] 对称二叉树</li></ul><h2 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h2><h3 id="动态规划概念"><a href="#动态规划概念" class="headerlink" title="动态规划概念"></a>动态规划概念</h3><ol><li><p>动态规划是 <strong>算法设计</strong> 中的一种方法</p></li><li><p>它将一个问题分解为 <strong>相互重叠</strong> 的子问题，通过反复求解子问题，来解决原来的问题</p></li></ol><h3 id="动态规划场景"><a href="#动态规划场景" class="headerlink" title="动态规划场景"></a>动态规划场景</h3><ul><li>场景一：斐波那契数列<ul><li>定义子问题：F(n) = F(n-1) + F(n-2)</li><li>反复执行：从2循环到n，执行上述公式</li></ul></li></ul><p><img src="//cdn.zhiyuchangxin.cn/sf-fbnq.png" style="display:block;max-width:600px;"></p><h3 id="Leetcode-练习-1"><a href="#Leetcode-练习-1" class="headerlink" title="Leetcode 练习"></a>Leetcode 练习</h3><ul><li>[70] 爬楼梯</li><li>[198] 打家劫舍</li><li>[213] 打家劫舍2</li><li>[337] 打家劫舍3</li><li>[121] 买卖股票的最佳时机</li><li>[122] 买卖股票的最佳时机2</li><li>[714] 买卖股票的最佳时机含手续费</li><li>[309] 买卖股票的最佳时机含冷冻费</li><li>[123] 买卖股票的最佳时机3</li><li>[188] 买卖股票的最佳时机4</li></ul><h2 id="三、贪心算法"><a href="#三、贪心算法" class="headerlink" title="三、贪心算法"></a>三、贪心算法</h2><h3 id="贪心算法概念"><a href="#贪心算法概念" class="headerlink" title="贪心算法概念"></a>贪心算法概念</h3><ol><li><p>贪心算法是 <strong>算法设计</strong> 中的一种方法</p></li><li><p>期盼通过每个阶段的 <strong>局部最优</strong> 选择，从而到达全局的最优</p></li><li><p>结果并 <strong>不一定是最优</strong></p></li></ol><h3 id="贪心算法场景"><a href="#贪心算法场景" class="headerlink" title="贪心算法场景"></a>贪心算法场景</h3><ul><li>场景一：零钱兑换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 得到了最优解</span><br><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3</span><br><span class="line">解释：11 = 5 + 5 + 1</span><br><span class="line"></span><br><span class="line">// 未得到最优解</span><br><span class="line">输入：coins = [1, 3, 4], amount = 6</span><br><span class="line">输出：3</span><br><span class="line">解释：6 = 4 + 1 + 1</span><br></pre></td></tr></table></figure><h3 id="Leetcode-练习-2"><a href="#Leetcode-练习-2" class="headerlink" title="Leetcode 练习"></a>Leetcode 练习</h3><ul><li>[455] 分饼干</li><li>[122] 买卖股票的最佳时机</li></ul><h2 id="四、回溯算法"><a href="#四、回溯算法" class="headerlink" title="四、回溯算法"></a>四、回溯算法</h2><h3 id="回溯算法概念"><a href="#回溯算法概念" class="headerlink" title="回溯算法概念"></a>回溯算法概念</h3><ol><li><p>回溯算法是 <strong>算法设计</strong> 中的一种方法</p></li><li><p>回溯算法是一种 <strong>渐进式</strong> 寻找并构建问题解决方案的策略</p></li><li><p>回溯算法会先选择一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决</p></li></ol><h3 id="回溯算法场景"><a href="#回溯算法场景" class="headerlink" title="回溯算法场景"></a>回溯算法场景</h3><blockquote><p>有很多路<br>这些路里，有<strong>死路</strong>，也有<strong>出路</strong><br>通常需要递归来模拟所有的路</p></blockquote><ul><li>场景一：全排列<ul><li>用递归模拟出所有的情况</li><li>遇到包含重复元素的情况，就回溯</li><li>收集所有到达递归终点的情况，并返回</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 2, 3]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [1, 3, 2],</span><br><span class="line">    [2, 1, 3],</span><br><span class="line">    [2, 3, 1],</span><br><span class="line">    [3, 1, 2],</span><br><span class="line">    [3, 2, 1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Leetcode-练习-3"><a href="#Leetcode-练习-3" class="headerlink" title="Leetcode 练习"></a>Leetcode 练习</h3><ul><li>[46] 全排列</li><li>[78] 子集</li></ul><hr><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>需要枚举数组中的两个元素时，若随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法</p><blockquote><p>未完待续</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计思想总是太抽象，这里没有整理的很好（囧）。&lt;br&gt;但既然说了要做三次总结，要说到做到，这里先做个标记，待后面有深入的思考后再重新整理。&lt;br&gt;对算法设计思想有深入思考的同学可以暂时忽略这篇文章~&lt;br&gt;在学习的过程中需重点关注以下几点：算法的特点、应用场景、时间复杂度、空间复杂度…  &lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="//blog.zhiyuchangxin.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JS 版排序与搜索——进阶篇</title>
    <link href="//blog.zhiyuchangxin.cn/articles/arithmetic-two/index.html"/>
    <id>//blog.zhiyuchangxin.cn/articles/arithmetic-two/index.html</id>
    <published>2020-12-06T02:00:00.000Z</published>
    <updated>2020-12-25T10:01:30.633Z</updated>
    
    <content type="html"><![CDATA[<p>本文为算法系列学习的第二篇，希望通过这篇文章系统的对排序与搜索算法做一次梳理。<br>文中仅总结了常见的几种排序与搜索算法，还有一些未总结到的，感兴趣的可以自己学习一下~<br>在学习的过程中需重点关注以下几点：算法的特点、应用场景、时间复杂度、空间复杂度…<br>准备好了吗，让我们开始吧~  </p><a id="more"></a><h2 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h2><h3 id="排序总览"><a href="#排序总览" class="headerlink" title="排序总览"></a>排序总览</h3><table><thead><tr><th>排序方式</th><th>时间复杂度(平均)</th><th>时间复杂度(最坏)</th><th>时间复杂度(最好)</th><th>空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td style="text-align:center">稳定</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td style="text-align:center">稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td style="text-align:center">稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(nlogn)</td><td>O(nlogn)</td><td style="text-align:center">不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td style="text-align:center">不稳定</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td style="text-align:center"></td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td style="text-align:center">稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n^2)</td><td>O(n)</td><td>O(n+k)</td><td style="text-align:center">稳定</td></tr><tr><td>基数排序</td><td>O(n*K)</td><td>O(n*K)</td><td>O(n*K)</td><td>O(n+K)</td><td style="text-align:center">稳定</td></tr></tbody></table><blockquote><p>稳定性：如果a=b，排序前a在b前面，排序后a仍然在b前面，则称算法稳定，否则不稳定</p></blockquote><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>比较所有相邻元素，如果第一个比第二个大，则交换他们</li><li>一轮下来，可以保证最后一个数是最大的</li><li>执行 n-1 轮就可以完成排序</li></ol><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://cdn.zhiyuchangxin.cn/sf-bubble.gif" alt="冒泡排序.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[j] &gt; <span class="keyword">this</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">let</span> t = <span class="keyword">this</span>[j]</span><br><span class="line">                <span class="keyword">this</span>[j] = <span class="keyword">this</span>[j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">this</span>[j + <span class="number">1</span>] = t</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">arr.bubbleSort()</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>找到数组中的最小值，选中他并将其放置在第一位</li><li>接着找到第二小的值，选中他并将其放置在第二位</li><li>以此类推，执行 n-1 轮</li></ol><h4 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://cdn.zhiyuchangxin.cn/sf-selection.gif" alt="选择排序.gif"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; <span class="keyword">this</span>.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[j] &lt; <span class="keyword">this</span>[minIndex]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i !== minIndex) &#123;</span><br><span class="line">            <span class="keyword">let</span> t = <span class="keyword">this</span>[i]</span><br><span class="line">            <span class="keyword">this</span>[i] = <span class="keyword">this</span>[minIndex]</span><br><span class="line">            <span class="keyword">this</span>[minIndex] = t</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">arr.selectionSort()</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h3 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h3><h4 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>从第二个数开始往前比</li><li>比他大就往后排</li><li>以此类推进行到最后一个数</li></ol><h4 id="动画演示-2"><a href="#动画演示-2" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://cdn.zhiyuchangxin.cn/sf-insertion.gif" alt="插入排序.gif"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">let</span> j = i</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            <span class="keyword">this</span>[j] = <span class="keyword">this</span>[j - <span class="number">1</span>]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">arr.insertionSort()</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><blockquote><p>小型数组排序时：插入比冒泡、选择排序性能要好</p></blockquote><h3 id="1-4-归并排序"><a href="#1-4-归并排序" class="headerlink" title="1.4 归并排序"></a>1.4 归并排序</h3><h4 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>分：把数组劈成两半，再递归的对子数组进行“分”操作，直至分成一个个单独的数</li><li>合：把两个数合并为有序数组，再对有序数组进行合并，直至全部子数组合并为一个完整的数组<ul><li>新建一个空数组 res，用于存放最终排序后的数组</li><li>比较两个有序数组的头部，较小者出队并推入 res 中</li><li>如果两个数组还有值，就重复第二步</li></ul></li></ol><h4 id="动画演示-3"><a href="#动画演示-3" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://cdn.zhiyuchangxin.cn/sf-merge.gif" alt="归并排序.gif"></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> rec = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 分</span></span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>, mid)</span><br><span class="line">        <span class="keyword">const</span> right = arr.slice(mid, arr.length)</span><br><span class="line">        <span class="keyword">const</span> orderLeft = rec(left)</span><br><span class="line">        <span class="keyword">const</span> orderRight = rec(right)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合</span></span><br><span class="line">        <span class="keyword">const</span> res = []</span><br><span class="line">        <span class="keyword">while</span> (orderLeft.length || orderRight.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (orderLeft.length &amp;&amp; orderRight.length) &#123;</span><br><span class="line">                res.push(orderLeft[<span class="number">0</span>] &lt; orderRight[<span class="number">0</span>] ? orderLeft.shift() : orderRight.shift())</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderLeft.length) &#123;</span><br><span class="line">                res.push(orderLeft.shift())</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderRight.length) &#123;</span><br><span class="line">                res.push(orderRight.shift())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = rec(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环赋值</span></span><br><span class="line">    res.forEach(<span class="function">(<span class="params">el, i</span>) =&gt;</span> <span class="keyword">this</span>[i] = el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">arr.mergeSort()</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n*logn)<ul><li>【分】时间复杂度：O(logn)</li><li>【合】时间复杂度：O(n)</li></ul></li><li>空间复杂度：O(n)</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>归并排序始终能保证其 <strong>O(nlogn)</strong> 的性能（因此非常适合分类 <strong>大量</strong> 的输入）</li><li>归并排序是一个稳定的排序算法</li><li>在归并操作期间需要额外的 <strong>O(n)</strong> 的存储</li></ul><blockquote><p>==「火狐浏览器」使用「归并算法」实现 sort==</p></blockquote><h3 id="1-5-快速排序"><a href="#1-5-快速排序" class="headerlink" title="1.5 快速排序"></a>1.5 快速排序</h3><h4 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>分区：从数组中任意选择一个基准，所有比基准小的元素放在基准的前面，比基准大的元素放在基准的后面</li><li>递归：递归的对基准前后的子数组进行分区</li></ol><h4 id="动画演示-4"><a href="#动画演示-4" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://cdn.zhiyuchangxin.cn/sf-quick.gif" alt="快速排序.gif"></p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.quickSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> rec = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">const</span> left = [] <span class="comment">// 左区</span></span><br><span class="line">        <span class="keyword">const</span> right = [] <span class="comment">// 右区</span></span><br><span class="line">        <span class="keyword">const</span> mid = arr[<span class="number">0</span>] <span class="comment">// 基准</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; mid) &#123;</span><br><span class="line">                left.push(arr[i])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [...rec(left), mid, ...rec(right)]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = rec(<span class="keyword">this</span>)</span><br><span class="line">    res.forEach(<span class="function">(<span class="params">el, i</span>) =&gt;</span> <span class="keyword">this</span>[i] = el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">arr.quickSort()</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n*logn)<ul><li>【递归】时间复杂度：O(logn)</li><li>【分区】时间复杂度：O(n)</li></ul></li><li>空间复杂度：==? O(n*logn)==</li></ul><blockquote><p>==<em>「老版 chrome」== 使用 ==「快速排序」== 实现 sort<br>==</em>「新版 chrome」==<br>【1】当数组 ==length &lt;= 10== 时使用 ==「插入排序」== 实现 sort<br>【2】当数组 ==length &gt; 10== 时使用 ==「快速排序」== 实现 sort</p></blockquote><h4 id="➡️-随机快速排序"><a href="#➡️-随机快速排序" class="headerlink" title="➡️ 随机快速排序"></a>➡️ 随机快速排序</h4><ul><li>除了执行分区算法之外，与快速排序相同</li><li>随机选择 a[i..j] 之间的枢轴，而不是始终选择 a[i]（或 a[i..j]之间的任何其他固定索引）</li><li>…</li></ul><h3 id="1-6-堆排序"><a href="#1-6-堆排序" class="headerlink" title="1.6 堆排序"></a>1.6 堆排序</h3><h4 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>构建最小堆</li><li>挨个将堆顶出堆，直至堆为空</li></ol><h4 id="动画演示-5"><a href="#动画演示-5" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://cdn.zhiyuchangxin.cn/sf-heap.gif" alt="堆排序"></p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小堆类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line"><span class="keyword">this</span>.heap = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换操作</span></span><br><span class="line">swap(i1, i2) &#123;</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">this</span>.heap[i1]</span><br><span class="line"><span class="keyword">this</span>.heap[i1] = <span class="keyword">this</span>.heap[i2]</span><br><span class="line"><span class="keyword">this</span>.heap[i2] = t</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取父节点索引</span></span><br><span class="line">getPindex(i) &#123;</span><br><span class="line"><span class="keyword">return</span> (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取左节点索引</span></span><br><span class="line">getLindex(i) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取右节点索引</span></span><br><span class="line">getRindex(i) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上移操作</span></span><br><span class="line">shiftUp(index) &#123;</span><br><span class="line"><span class="keyword">if</span> (index === <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">const</span> pIndex = <span class="keyword">this</span>.getPindex(index)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.heap[index] &lt; <span class="keyword">this</span>.heap[pIndex]) &#123;</span><br><span class="line"><span class="keyword">this</span>.swap(index, pIndex)</span><br><span class="line"><span class="keyword">this</span>.shiftUp(pIndex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下移操作</span></span><br><span class="line">shiftDown(index) &#123;</span><br><span class="line"><span class="keyword">if</span> (index === <span class="keyword">this</span>.heap.length - <span class="number">1</span>) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">const</span> lIndex = <span class="keyword">this</span>.getLindex(index)</span><br><span class="line"><span class="keyword">const</span> rIndex = <span class="keyword">this</span>.getRindex(index)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.heap[index] &gt; <span class="keyword">this</span>.heap[lIndex]) &#123;</span><br><span class="line"><span class="keyword">this</span>.swap(index, lIndex)</span><br><span class="line"><span class="keyword">this</span>.shiftDown(lIndex)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.heap[index] &gt; <span class="keyword">this</span>.heap[rIndex]) &#123;</span><br><span class="line"><span class="keyword">this</span>.swap(index, rIndex)</span><br><span class="line"><span class="keyword">this</span>.shiftDown(rIndex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="comment">//   1. 插入堆底（即数组尾部）</span></span><br><span class="line"><span class="comment">//   2. 上移操作：将新堆底和他的父节点进行交换，直至父节点小于等于新堆底</span></span><br><span class="line"><span class="comment">//   时间复杂度：O(logk)  k为堆的大小</span></span><br><span class="line">insert(n) &#123;</span><br><span class="line"><span class="keyword">this</span>.heap.push(n)</span><br><span class="line"><span class="keyword">this</span>.shiftUp(<span class="keyword">this</span>.heap.length - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">//   1. 数组尾部元素替换堆顶（直接删除堆顶会破坏堆的结构）</span></span><br><span class="line"><span class="comment">//   2. 下移操作：将新堆顶和他的子节点进行交换，直到子节点大于等于新堆顶</span></span><br><span class="line"><span class="comment">//   时间复杂度：O(logk)  k为堆的大小</span></span><br><span class="line">pop() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.heap[<span class="number">0</span>] = <span class="keyword">this</span>.heap.pop()</span><br><span class="line">            <span class="keyword">this</span>.shiftDown(<span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.heap.pop()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆顶元素</span></span><br><span class="line">peek() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.heap[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆大小</span></span><br><span class="line">size() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.heap.length</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.heapSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> minheap = <span class="keyword">new</span> MinHeap()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        minheap.insert(<span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>[i] = minheap.peek()</span><br><span class="line">        minheap.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">arr.heapSort()</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n*logn)</li><li>空间复杂度：O(n)  ==如何实现 O(1) ？==</li></ul><h2 id="二、搜索"><a href="#二、搜索" class="headerlink" title="二、搜索"></a>二、搜索</h2><h3 id="2-1-顺序搜索"><a href="#2-1-顺序搜索" class="headerlink" title="2.1 顺序搜索"></a>2.1 顺序搜索</h3><h4 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>遍历数组</li><li>若找到跟目标值相等的元素，则搜索结束返回其下标</li><li>若遍历结束仍未找到目标值，则搜索结束返回 -1</li></ol><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序搜索</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.sequentialSearch = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>[i] === n) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">arr.sequentialSearch(<span class="number">1</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="2-2-二分搜索"><a href="#2-2-二分搜索" class="headerlink" title="2.2 二分搜索"></a>2.2 二分搜索</h3><h4 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>前提：数组 <strong>有序</strong></li><li>从数组的 <strong>中间元素</strong> 开始搜索</li><li>若中间元素刚好 <strong>等于</strong> 目标值，则搜索结束返回其下标</li><li>若目标值 <strong>大于/小于</strong> 中间元素，则在 <strong>大于/小于</strong> 中间元素的那一半数组中继续搜索</li></ol><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.binarySearch = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> high = <span class="keyword">this</span>.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (high &gt;= low) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> el = <span class="keyword">this</span>[mid]</span><br><span class="line">        <span class="keyword">if</span> (n === el) <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> (n &gt; el) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>].sort() <span class="comment">// [1,2,3,4,5,6,8]</span></span><br><span class="line">arr.binarySearch(<span class="number">3</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h4 id="Leetcode-练习"><a href="#Leetcode-练习" class="headerlink" title="Leetcode 练习"></a>Leetcode 练习</h4><ul><li>[374] 猜数字大小</li><li>[69] x的平方根</li></ul><h3 id="2-3-其他搜索（详情待补充）"><a href="#2-3-其他搜索（详情待补充）" class="headerlink" title="2.3 其他搜索（详情待补充）"></a>2.3 其他搜索（详情待补充）</h3><ul><li>插值查找</li><li>斐波那契查找</li><li>树表查找</li><li>分块查找</li><li>哈希查找</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为算法系列学习的第二篇，希望通过这篇文章系统的对排序与搜索算法做一次梳理。&lt;br&gt;文中仅总结了常见的几种排序与搜索算法，还有一些未总结到的，感兴趣的可以自己学习一下~&lt;br&gt;在学习的过程中需重点关注以下几点：算法的特点、应用场景、时间复杂度、空间复杂度…&lt;br&gt;准备好了吗，让我们开始吧~  &lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="//blog.zhiyuchangxin.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JS 版数据结构与算法——基础篇</title>
    <link href="//blog.zhiyuchangxin.cn/articles/arithmetic-one/index.html"/>
    <id>//blog.zhiyuchangxin.cn/articles/arithmetic-one/index.html</id>
    <published>2020-11-30T02:00:00.000Z</published>
    <updated>2020-12-25T09:56:01.645Z</updated>
    
    <content type="html"><![CDATA[<p>本次系列学习，主要是从前端的视角出发，梳理前端与算法的结合点。<br>常见知识点大致被拆分成下图展示的三个模块：数据结构、进阶算法、算法设计思想。<br>本文为基础篇，主要学习第一部分——数据结构。<br>在学习的过程中需重点关注以下几点：算法的特点、应用场景、时间复杂度、空间复杂度…  </p><a id="more"></a><p><img src="//cdn.zhiyuchangxin.cn/sf-catalogue.png" alt="image.png"></p><p>接下来，我们将按照下面的目录顺序依次展开：</p><blockquote><ul><li style="list-style: none"><input type="checkbox" checked> 栈</li><li style="list-style: none"><input type="checkbox" checked> 队列</li><li style="list-style: none"><input type="checkbox" checked> 链表</li><li style="list-style: none"><input type="checkbox" checked> 集合</li><li style="list-style: none"><input type="checkbox" checked> 字典</li><li style="list-style: none"><input type="checkbox" checked> 树</li><li style="list-style: none"><input type="checkbox" checked> 图</li><li style="list-style: none"><input type="checkbox" checked> 堆</li></ul></blockquote><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>针对所列出的数据结构，我们再细分为<strong>有序</strong>数据结构、<strong>无序</strong>数据结构、<strong>复杂</strong>数据结构三组，由易到难渐进式的学习。</p><p>补齐概念：</p><ol><li>时间复杂度：<strong>定性</strong>描述算法的运行时间</li></ol><p><img src="//cdn.zhiyuchangxin.cn/sf-time-fzd.png" style="display:block;max-width:600px;"></p><ol><li>空间复杂度：算法在运行过程中临时占用存储空间大小的度量</li></ol><h2 id="一、有序数据结构"><a href="#一、有序数据结构" class="headerlink" title="一、有序数据结构"></a>一、有序数据结构</h2><p>有序数据结构主要包括以下三个：</p><blockquote><ul><li style="list-style: none"><input type="checkbox" checked> 栈</li><li style="list-style: none"><input type="checkbox" checked> 队列</li><li style="list-style: none"><input type="checkbox" checked> 链表</li></ul></blockquote><h3 id="1-1-栈"><a href="#1-1-栈" class="headerlink" title="1.1 栈"></a>1.1 栈</h3><ul><li><p>栈是一个 <strong>后进先出</strong> 的数据结构</p></li><li><p>Js 中没有栈，但可以使用 <strong><code>Array</code></strong> 实现栈的所有功能</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (arr) &#123;</span><br><span class="line">        <span class="keyword">this</span>.stack = arr || []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    push (item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.stack.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    pop () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    peek () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stack.length</span><br><span class="line">            ? <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length - <span class="number">1</span>]</span><br><span class="line">            : <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    empty () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stack.length === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>栈的应用场景：</p><ul><li>十进制转二进制</li><li>判断字符串的括号是否有效</li><li><strong>函数调用堆栈</strong></li><li>……</li></ul></li><li><p>LeetCode 练习：</p><ul><li>[20] 有效的括号</li><li>[144] 二叉树的前序遍历</li></ul></li></ul><h3 id="1-2-队列"><a href="#1-2-队列" class="headerlink" title="1.2 队列"></a>1.2 队列</h3><ul><li><p>队列是一个 <strong>先进先出</strong> 的数据结构</p></li><li><p>Js 中没有队列，但可以使用 <strong><code>Array</code></strong> 实现队列的所有功能</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (arr) &#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = arr || []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    push (item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    shift () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取队头元素</span></span><br><span class="line">    peek () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="number">0</span>] || <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断队是否为空</span></span><br><span class="line">    empty () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue.length === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>队列的应用场景：</p><ul><li>计算最近请求次数</li><li><strong>js 异步中的任务队列</strong></li></ul></li><li><p>应用场景拓展——<strong>任务队列</strong>：</p><ul><li>简单概括 js 的事件循环与任务队列（不展开细讲） </li><li>如图所示：<img src="//cdn.zhiyuchangxin.cn/sf-eventloop.png" style="display:block;max-width:600px;"></li><li>1.当异步代码返回结果后会放到<strong>任务队列</strong>中</li><li>2.待调用栈中的代码执行完毕，js 引擎便会启动轮询机制</li><li>3.到任务队列中依次查找并放到调用栈中执行</li></ul></li><li><p>LeetCode 练习：</p><ul><li>[933] 最近请求次数</li></ul></li></ul><h3 id="1-3-链表"><a href="#1-3-链表" class="headerlink" title="1.3 链表"></a>1.3 链表</h3><ul><li><p>链表是多个元素组成的列表，元素存储不连续，用 next 指针连在一起  <img src="//cdn.zhiyuchangxin.cn/sf-link.png" style="display:block;max-width:500px;"></p></li><li><p>数组 VS 链表</p><ul><li>数组：增删非首尾元素时，需要移动该元素之后的所有元素</li><li>链表：增删非首尾元素时，无需移动元素，只需更改 next 指向即可</li></ul></li><li><p>Js 中没有链表，但可以使用 <strong><code>Object</code></strong> 模拟链表</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js 模拟链表</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">val</span>: <span class="string">'a'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">val</span>: <span class="string">'b'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">val</span>: <span class="string">'c'</span> &#125;</span><br><span class="line">a.next = b</span><br><span class="line">b.next = c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表（重点）</span></span><br><span class="line"><span class="keyword">let</span> p = a</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p.val)</span><br><span class="line">    p = p.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">const</span> d = &#123; <span class="attr">val</span>: <span class="string">'d'</span> &#125;</span><br><span class="line">b.next = d</span><br><span class="line">d.next = c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">b.next = c</span><br></pre></td></tr></table></figure><ul><li><p>链表的应用场景：</p><ul><li>js 中的<strong>原型链</strong></li><li>获取 json 的节点值</li><li>……</li></ul></li><li><p>应用场景拓展——<strong>原型链</strong>：</p><ul><li>原型链的本质是链表</li><li>原型链上的节点是各种原型对象 （eg: Function.prototype、Object.prototype…）</li><li>原型链通过 <strong><code>__proto__</code></strong> 属性连接各种原型对象</li><li>特性1：如果 A 沿着原型链能找到 B.prototype，那么 A instanceof B 为 true</li><li>特性2：如果在 A 对象上没有找到 x 属性，那么会沿着原型链继续查找</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特性1 练习：简述 instanceof 的原理，并用代码实现</span></span><br><span class="line"><span class="comment">// 分析：遍历 A 的原型链，如果能找到 B.prototype 则返回 true，否则返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">instanceof</span> = <span class="function">(<span class="params">A, B</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = A</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p === B.prototype) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特性2 练习：</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.b = <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a)  <span class="comment">// a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b)  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(func.a)  <span class="comment">// a</span></span><br><span class="line"><span class="built_in">console</span>.log(func.b)  <span class="comment">// b</span></span><br></pre></td></tr></table></figure><ul><li>应用场景拓展——获取 json 节点值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    a: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    d: &#123; <span class="attr">e</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> path = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = data</span><br><span class="line">path.forEach(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">    p = p[el]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>LeetCode 练习：<ul><li>[237] 删除链表中的节点：将被删除节点转移到下个节点</li><li>[206] 反转链表：1.双指针一前一后遍历链表；2.反转双指针</li><li>[2] 两数相加</li><li>[83] 删除排序链表中的重复元素</li><li>[141] 环形链表：一快一慢两个指针遍历链表，如果指针能够相逢，说明链表有环</li><li>[234] 回文链表</li></ul></li></ul><h2 id="二、无序数据结构"><a href="#二、无序数据结构" class="headerlink" title="二、无序数据结构"></a>二、无序数据结构</h2><p>无序数据结构主要包括以下两个：</p><blockquote><ul><li style="list-style: none"><input type="checkbox" checked> 集合</li><li style="list-style: none"><input type="checkbox" checked> 字典</li></ul></blockquote><h3 id="2-1-集合"><a href="#2-1-集合" class="headerlink" title="2.1 集合"></a>2.1 集合</h3><ul><li><p>集合是一种 <strong>无序且唯一</strong> 的数据结构</p></li><li><p>ES6 中有集合——Set</p></li><li><p>集合的常用操作：去重、判断某元素是否在集合中、求交集</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line">set.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line">set.delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素是否在集合中</span></span><br><span class="line">set.has(<span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合迭代</span></span><br><span class="line"><span class="comment">// for (let item of set) console.log(item)</span></span><br><span class="line"><span class="comment">// for (let item of set.keys()) console.log(item)</span></span><br><span class="line"><span class="comment">// for (let item of set.values()) console.log(item)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> set.entries()) <span class="built_in">console</span>.log(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合求交集</span></span><br><span class="line"><span class="keyword">const</span> set3 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">el</span> =&gt;</span> set2.has(el)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合求差集</span></span><br><span class="line"><span class="keyword">const</span> set4 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">el</span> =&gt;</span> !set2.has(el)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line"><span class="keyword">const</span> arr3 = [...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure><ul><li>LeetCode 练习：<ul><li>[349] 两个数组的交集</li></ul></li></ul><h3 id="2-2-字典"><a href="#2-2-字典" class="headerlink" title="2.2 字典"></a>2.2 字典</h3><ul><li><p>字典是一种以 <strong>键值对的形式存储唯一值</strong> 的数据结构</p></li><li><p>ES6 中有字典——Map</p></li><li><p>字典的常用操作：键值对的增、删、改、查</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line">map.set(<span class="string">'a'</span>, <span class="string">'aa'</span>)</span><br><span class="line">map.set(<span class="string">'b'</span>, <span class="string">'bb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line">map.delete(<span class="string">'b'</span>)</span><br><span class="line"><span class="comment">// map.clear()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">map.set(<span class="string">'a'</span>, <span class="string">'cc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line">map.get(<span class="string">'a'</span>) <span class="comment">// 'aa'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素是否在字典中</span></span><br><span class="line">map.has(<span class="string">'a'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>思考：比较 Map 和 Object 频繁增删操作的性能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同循环体内测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Map 频繁进行增删</span></span><br><span class="line"><span class="keyword">const</span> t11 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">    map.set(i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t12 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Map增加时间：'</span>, t12 - t11) <span class="comment">// 138</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t21 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">    map.delete(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t22 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Map删除时间：'</span>, t22 - t21) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Map增删总时间：'</span>, t22 - t11) <span class="comment">// 266</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Object 频繁进行增删</span></span><br><span class="line"><span class="keyword">const</span> t31 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">    obj[i] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t32 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Object增加时间：'</span>, t32 - t31) <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t41 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span> obj[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t42 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Object删除时间：'</span>, t42 - t41) <span class="comment">// 60</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Object增删总时间：'</span>, t42 - t31) <span class="comment">// 104</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同一循环体内测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Map 频繁进行增删</span></span><br><span class="line"><span class="keyword">const</span> t1 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">    map.set(i, i)</span><br><span class="line">    map.delete(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t2 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Map增删总时间：'</span>, t2 - t1) <span class="comment">// 105</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Object 频繁进行增删</span></span><br><span class="line"><span class="keyword">const</span> t3 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">    obj[i] = i</span><br><span class="line">    <span class="keyword">delete</span> obj[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t4 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Object增删总时间：'</span>, t4 - t3) <span class="comment">// 285</span></span><br></pre></td></tr></table></figure><blockquote><p>结论：<br>1.不同循环体内频繁进行增删操作，Object 性能优于 Map<br>2.同一循环体内频繁进行增删操作，Map 性能优于 Object</p></blockquote><ul><li>LeetCode 练习：<ul><li>[349] 两个数组的交集</li><li>[20] 有效的括号</li><li>[1] 两数之和</li><li>[3] 无重复字符串的最长子串</li><li>[76] 最小覆盖子串</li></ul></li></ul><h2 id="三、复杂数据结构"><a href="#三、复杂数据结构" class="headerlink" title="三、复杂数据结构"></a>三、复杂数据结构</h2><p>还剩下三个稍微高级一点的数据结构：</p><blockquote><ul><li style="list-style: none"><input type="checkbox" checked> 树</li><li style="list-style: none"><input type="checkbox" checked> 图</li><li style="list-style: none"><input type="checkbox" checked> 堆</li></ul></blockquote><h3 id="3-1-树"><a href="#3-1-树" class="headerlink" title="3.1 树"></a>3.1 树</h3><ul><li><p>树是一种 <strong>分层</strong> 数据的抽象模型</p></li><li><p>前端常见的树：DOM 树、级联选择、树形控件、Json…</p></li><li><p>Js 中没有树，但可以使用 <strong><code>Object</code></strong> 和 <strong><code>Array</code></strong> 来构建树</p></li><li><p>树的常用操作：</p><ul><li><strong>深度优先遍历</strong>：尽可能深的搜索树的分支</li><li>广度优先遍历：先访问离根节点最近的节点</li><li>二叉树的先序遍历</li><li>二叉树的中序遍历</li><li>二叉树的后序遍历</li></ul></li><li><p>树的 <strong>深度优先遍历</strong></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先遍历步骤：</span></span><br><span class="line"><span class="comment"> *   1. 访问根节点</span></span><br><span class="line"><span class="comment"> *   2. 对根节点的 children 挨个进行深度优先遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dfs = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(root.val)</span><br><span class="line">    root.children.forEach(dfs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先遍历应用场景：获取 json 节点值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = &#123;</span><br><span class="line">    a: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    d: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dfs = <span class="function">(<span class="params">n, path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n, path)</span><br><span class="line">    <span class="built_in">Object</span>.keys(n).forEach(<span class="function">(<span class="params">k</span>) =&gt;</span> &#123;</span><br><span class="line">        dfs(n[k], path.concat(k))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(json, [])</span><br></pre></td></tr></table></figure><ul><li>树的 <strong>广度优先遍历</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先遍历步骤：</span></span><br><span class="line"><span class="comment"> *   1. 新建一个队列，把根节点入队</span></span><br><span class="line"><span class="comment"> *   2. 把对头出队并访问</span></span><br><span class="line"><span class="comment"> *   3. 把对头的 children 挨个入队</span></span><br><span class="line"><span class="comment"> *   4. 重复2、3步，直到队列为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bfs = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> q = [root]</span><br><span class="line">    <span class="keyword">while</span> (q.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = q.shift()</span><br><span class="line">        <span class="built_in">console</span>.log(data.val)</span><br><span class="line">        data.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> q.push(child))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二叉树的 <strong>先序遍历</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序遍历步骤：</span></span><br><span class="line"><span class="comment"> *   1. 访问根节点</span></span><br><span class="line"><span class="comment"> *   2. 对根节点的左子树进行先序遍历</span></span><br><span class="line"><span class="comment"> *   3. 对根节点的右子树进行先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 递归版</span></span><br><span class="line"><span class="keyword">const</span> preorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">console</span>.log(root.val)</span><br><span class="line">    preorder(root.left)</span><br><span class="line">    preorder(root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归版</span></span><br><span class="line"><span class="keyword">const</span> preorder2 = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> stack = [root]</span><br><span class="line">    <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = stack.pop()</span><br><span class="line">        <span class="built_in">console</span>.log(n.val)</span><br><span class="line">        n.right &amp;&amp; stack.push(n.right)</span><br><span class="line">        n.left &amp;&amp; stack.push(n.left)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二叉树的 <strong>中序遍历</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历步骤：</span></span><br><span class="line"><span class="comment"> *   1. 对根节点的左子树进行中序遍历</span></span><br><span class="line"><span class="comment"> *   2. 访问根节点</span></span><br><span class="line"><span class="comment"> *   3. 对根节点的右子树进行中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版</span></span><br><span class="line"><span class="keyword">const</span> inorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    inorder(root.left)</span><br><span class="line">    <span class="built_in">console</span>.log(root.val)</span><br><span class="line">    inorder(root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归版</span></span><br><span class="line"><span class="keyword">const</span> inorder2 = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> p = root</span><br><span class="line">    <span class="keyword">while</span> (stack.length || p) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            stack.push(p)</span><br><span class="line">            p = p.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> n = stack.pop()</span><br><span class="line">        <span class="built_in">console</span>.log(n.val)</span><br><span class="line">        p = n.right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二叉树的 <strong>后序遍历</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历步骤：</span></span><br><span class="line"><span class="comment"> *   1. 对根节点的左子树进行后序遍历</span></span><br><span class="line"><span class="comment"> *   2. 对根节点的右子树进行后序遍历</span></span><br><span class="line"><span class="comment"> *   3. 访问根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版</span></span><br><span class="line"><span class="keyword">const</span> postorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    postorder(root.left)</span><br><span class="line">    postorder(root.right)</span><br><span class="line">    <span class="built_in">console</span>.log(root.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归版</span></span><br><span class="line"><span class="keyword">const</span> postorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> outstack = []</span><br><span class="line">    <span class="keyword">const</span> stack = [root]</span><br><span class="line">    <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = stack.pop()</span><br><span class="line">        outstack.push(n)</span><br><span class="line">        n.left &amp;&amp; stack.push(n.left)</span><br><span class="line">        n.right &amp;&amp; stack.push(n.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (outstack.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = outstack.pop()</span><br><span class="line">        <span class="built_in">console</span>.log(n.val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LeetCode 练习：<ul><li>[104] 二叉树的最大深度</li><li>[111] 二叉树的最小深度</li><li>[102] 二叉树的层序遍历</li><li>[94] 二叉树的中序遍历</li><li>[112] 路径总和</li></ul></li></ul><h3 id="3-2-图"><a href="#3-2-图" class="headerlink" title="3.2 图"></a>3.2 图</h3><ul><li><p>图是 <strong>网络结构</strong> 的抽象模型，是一组由 <strong>边</strong> 连接的 <strong>节点</strong></p></li><li><p>图可以表示任何二元关系  eg：道路、航班…</p></li><li><p>Js 中没有图，但可以使用 <strong><code>Object</code></strong> 和 <strong><code>Array</code></strong> 来构建图</p></li><li><p>图的表示法：邻接矩阵、邻接表、关联矩阵…</p></li><li><p>图的常用操作：</p><ul><li><strong>深度优先遍历</strong>：尽可能深的搜索图的分支</li><li>广度优先遍历：先访问离根节点最近的节点</li></ul></li><li><p>图的 <strong>深度优先遍历</strong></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图的深度优先遍历:</span></span><br><span class="line"><span class="comment"> *   1. 访问根节点</span></span><br><span class="line"><span class="comment"> *   1. 对根节点没访问过的相邻节点挨个进行深度优先遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dfs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n)</span><br><span class="line">    visited.add(n)</span><br><span class="line">    graph[n].forEach(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(el)) &#123;</span><br><span class="line">            dfs(el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>图的 <strong>广度优先遍历</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图的广度优先遍历</span></span><br><span class="line"><span class="comment"> *   1. 新建一个队列，将根节点入队</span></span><br><span class="line"><span class="comment"> *   2. 对头出队并访问</span></span><br><span class="line"><span class="comment"> *   3. 将对头没有访问过的相邻节点挨个入队</span></span><br><span class="line"><span class="comment"> *   4. 循环2，3步，直至队列为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bfs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> q = [n]</span><br><span class="line">    visited.add(n)</span><br><span class="line">    <span class="keyword">while</span> (q.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> top = q.shift()</span><br><span class="line">        <span class="built_in">console</span>.log(top)</span><br><span class="line">        graph[top].forEach(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.has(el)) &#123;</span><br><span class="line">                q.push(el)</span><br><span class="line">                visited.add(el)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LeetCode 练习：<ul><li>[65] 有效数字</li><li>[417] 太平洋大西洋水流问题、</li><li>[133] 克隆图</li></ul></li></ul><h3 id="3-3-堆"><a href="#3-3-堆" class="headerlink" title="3.3 堆"></a>3.3 堆</h3><ul><li><p>堆是一种特殊的 <strong>完全二叉树</strong></p></li><li><p>所有节点都 <strong>大于等于（最大堆）</strong> 或 <strong>小于等于（最小堆）</strong> 它的子节点</p></li><li><p>Js 中通常用 <strong><code>Array</code></strong> 表示堆 <img src="//cdn.zhiyuchangxin.cn/sf-heap.png" style="display:block;max-width:300px;"></p><ul><li>左侧子节点的位置：<code>2 * index + 1</code></li><li>右侧子节点的位置：<code>2 * index + 2</code></li><li>父节点的位置：<code>(index - 1) / 2</code></li></ul></li><li><p>堆的应用场景：</p><ul><li>高效快速的找出 <strong>最大值</strong> 和 <strong>最小值</strong> （时间复杂度<code>O(1)</code>）</li><li>查找第 <strong>K</strong> 个最大（最小）元素</li></ul></li><li><p>js 实现最小堆类</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line"><span class="keyword">this</span>.heap = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换操作</span></span><br><span class="line">swap(i1, i2) &#123;</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">this</span>.heap[i1]</span><br><span class="line"><span class="keyword">this</span>.heap[i1] = <span class="keyword">this</span>.heap[i2]</span><br><span class="line"><span class="keyword">this</span>.heap[i2] = t</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取父节点索引</span></span><br><span class="line">getPindex(i) &#123;</span><br><span class="line"><span class="keyword">return</span> (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取左节点索引</span></span><br><span class="line">getLindex(i) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取右节点索引</span></span><br><span class="line">getRindex(i) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上移操作</span></span><br><span class="line">shiftUp(index) &#123;</span><br><span class="line"><span class="keyword">if</span> (index === <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">const</span> pIndex = <span class="keyword">this</span>.getPindex(index)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.heap[index] &lt; <span class="keyword">this</span>.heap[pIndex]) &#123;</span><br><span class="line"><span class="keyword">this</span>.swap(index, pIndex)</span><br><span class="line"><span class="keyword">this</span>.shiftUp(pIndex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下移操作</span></span><br><span class="line">shiftDown(index) &#123;</span><br><span class="line"><span class="keyword">if</span> (index === <span class="keyword">this</span>.heap.length - <span class="number">1</span>) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">const</span> lIndex = <span class="keyword">this</span>.getLindex(index)</span><br><span class="line"><span class="keyword">const</span> rIndex = <span class="keyword">this</span>.getRindex(index)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.heap[index] &gt; <span class="keyword">this</span>.heap[lIndex]) &#123;</span><br><span class="line"><span class="keyword">this</span>.swap(index, lIndex)</span><br><span class="line"><span class="keyword">this</span>.shiftDown(lIndex)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.heap[index] &gt; <span class="keyword">this</span>.heap[rIndex]) &#123;</span><br><span class="line"><span class="keyword">this</span>.swap(index, rIndex)</span><br><span class="line"><span class="keyword">this</span>.shiftDown(rIndex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="comment">//   1. 插入堆底（即数组尾部）</span></span><br><span class="line"><span class="comment">//   2. 上移操作：将新堆底和他的父节点进行交换，直至父节点小于等于新堆底</span></span><br><span class="line"><span class="comment">//   时间复杂度：O(logk)  k为堆的大小</span></span><br><span class="line">insert(n) &#123;</span><br><span class="line"><span class="keyword">this</span>.heap.push(n)</span><br><span class="line"><span class="keyword">this</span>.shiftUp(<span class="keyword">this</span>.heap.length - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">//   1. 数组尾部元素替换堆顶（直接删除堆顶会破坏堆的结构）</span></span><br><span class="line"><span class="comment">//   2. 下移操作：将新堆顶和他的子节点进行交换，直到子节点大于等于新堆顶</span></span><br><span class="line"><span class="comment">//   时间复杂度：O(logk)  k为堆的大小</span></span><br><span class="line">pop() &#123;</span><br><span class="line"><span class="keyword">this</span>.heap[<span class="number">0</span>] = <span class="keyword">this</span>.heap.pop()</span><br><span class="line"><span class="keyword">this</span>.shiftDown(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆顶元素</span></span><br><span class="line">peek() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.heap[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆大小</span></span><br><span class="line">size() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.heap.length</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LeetCode 练习：<ul><li>[215] 数组中的第 K 个最大元素</li><li>[347] 前 K 个高频元素</li><li>[23] 合并 K 个排序链表</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次学习就到这里啦，虽然比较基础，但是不经常回顾还是容易忘的，有时间就多看看吧。<br>下一章会跟大家一起学习一下排序与搜索算法。期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次系列学习，主要是从前端的视角出发，梳理前端与算法的结合点。&lt;br&gt;常见知识点大致被拆分成下图展示的三个模块：数据结构、进阶算法、算法设计思想。&lt;br&gt;本文为基础篇，主要学习第一部分——数据结构。&lt;br&gt;在学习的过程中需重点关注以下几点：算法的特点、应用场景、时间复杂度、空间复杂度…  &lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="//blog.zhiyuchangxin.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>有关动画的思考与宏观总结</title>
    <link href="//blog.zhiyuchangxin.cn/articles/animation-all/index.html"/>
    <id>//blog.zhiyuchangxin.cn/articles/animation-all/index.html</id>
    <published>2019-09-07T09:30:00.000Z</published>
    <updated>2020-12-25T10:15:39.617Z</updated>
    
    <content type="html"><![CDATA[<p>前期曾细粒度的从多个角度对 web 动画做过一些研究，今天主要想从宏观的角度总结一下动画的实现以及目前主流的3D库。<br>在愈来愈追求极致体验的今天，Web开发者已经不满足于2D效果的实现，而把目标放到了更加炫酷的3D效果上。  </p><a id="more"></a><p>在Web3D百花齐放的今天，和大家简单探讨一下目前主流的3D库。  </p><h3 id="一、前期思考"><a href="#一、前期思考" class="headerlink" title="一、前期思考"></a>一、前期思考</h3><h4 id="实现成本"><a href="#实现成本" class="headerlink" title="实现成本"></a>实现成本</h4><p>动画的实现需要综合考虑两个方面的实现成本：</p><ol><li>前端技术实现</li><li>设计动画/模型实现</li></ol><h4 id="思考维度"><a href="#思考维度" class="headerlink" title="思考维度"></a>思考维度</h4><p>技术选型需要结合以下几个维度进行考量：</p><ol><li>开发语言的支持</li><li>2D、3D、VR的支持</li><li>性能</li><li>应用广度</li><li>设计理念</li><li>商业化成熟案例</li><li>学习资源与技术支持能力</li></ol><h3 id="二、动画分类"><a href="#二、动画分类" class="headerlink" title="二、动画分类"></a>二、动画分类</h3><p>下面总结一下动画的分类（非官方总结，如有不同意见欢迎指出~）</p><table><thead><tr><th>类别</th><th>分类</th></tr></thead><tbody><tr><td>技术方案</td><td>Js动画、css3动画、HTML5动画</td></tr><tr><td>交互类型</td><td>展示型动画、交互型动画</td></tr><tr><td>特殊效果</td><td>骨骼动画、粒子动画、差值动画…</td></tr><tr><td>维度</td><td>2D动画、拟3D动画、3D动画</td></tr></tbody></table><h4 id="技术方案分类："><a href="#技术方案分类：" class="headerlink" title="技术方案分类："></a>技术方案分类：</h4><ol><li><strong>Js 动画</strong>：很多成熟的 js 动画库…</li><li><strong>css3 动画</strong>：transition、animation、Animate.css库…</li><li><strong>HTML5 动画</strong>：svg、canvas、webgl…</li></ol><h4 id="交互类型分类："><a href="#交互类型分类：" class="headerlink" title="交互类型分类："></a>交互类型分类：</h4><ol><li><strong>展示型动画</strong>:（只要动画开始，就无法控制动画的状态）<ul><li>gif图</li><li>css3</li><li>canvas<ul><li>canvas上绘制的图形自身不支持DOM事件，只有canvas标签自身支持DOM事件监听</li><li>对canvas容器的事件进行处理，实现相对应事件的监听及处理）</li></ul></li><li>svg（同 canvas）</li><li>…</li></ul></li><li><strong>交互型动画</strong>:<ul><li>WebGL（WebGL在Android 4.4 Browser 不支持，可使用canvas优雅降级）</li><li>利用 JS 驱动的动画</li><li>…</li></ul></li></ol><h4 id="特殊效果分类："><a href="#特殊效果分类：" class="headerlink" title="特殊效果分类："></a>特殊效果分类：</h4><ul><li><strong>骨骼动画</strong>：多用于游戏、logo、彩蛋…<ul><li>设计方案对比：</li></ul></li></ul><table><thead><tr><th>名称</th><th>介绍</th><th>导出格式</th><th>收费情况</th><th>其他</th></tr></thead><tbody><tr><td>Dragonbones</td><td>白鹭时代退出的2D骨骼动画解决方案</td><td>支持JSON</td><td>免费</td><td>-</td></tr><tr><td>Spine</td><td>针对游戏开发的2D骨骼动画编辑工具</td><td>支持JSON</td><td>收费</td><td>-</td></tr><tr><td>万彩骨骼大师</td><td>专门制作2D动画任务/角色的软件</td><td>不支持JSON</td><td>免费</td><td>限windows系统</td></tr></tbody></table><ul><li><strong>粒子动画</strong>：canvas、Three.js…</li></ul><h4 id="维度分类："><a href="#维度分类：" class="headerlink" title="维度分类："></a>维度分类：</h4><ol><li>2D 动画</li><li>拟3D动画：2D动画通过变换模拟简单3D效果</li><li>3D 动画：Three.js、Egret、Layabox…</li></ol><h3 id="三、动画实现方案"><a href="#三、动画实现方案" class="headerlink" title="三、动画实现方案"></a>三、动画实现方案</h3><!--- 技术方案对比：--><!--- <img src="//pic1.58cdn.com.cn/nowater/iblog/n_v2dcaa9440c2674daf81591ce31686d8ac.png" style="margin:10px 0;width:60%;">--><table><thead><tr><th>Engine</th><th>2D Render</th><th>3D Render</th><th>JS</th><th>TS</th><th>2D 性能</th><th>3D 性能</th><th>精简后体积</th><th>其他</th></tr></thead><tbody><tr><td>Three.js</td><td><code>No</code></td><td>Yes</td><td>Yes</td><td><code>No</code></td><td><code>None</code></td><td>10</td><td>100K</td><td>JS 语言的 3D 库</td></tr><tr><td>Phaser</td><td>Yes</td><td><code>No</code></td><td>Yes</td><td>Yes</td><td>-</td><td>-</td><td>-</td><td>H5 游戏框架，引用 Pixi.js 渲染内核</td></tr><tr><td>Pixi.js</td><td>Yes</td><td><code>No</code></td><td>Yes</td><td>Yes</td><td>10</td><td><code>None</code></td><td>-</td><td>依赖于 canvas 的 WebGL 2D渲染器</td></tr><tr><td>Egret</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>10</td><td>10</td><td>-</td><td>游戏解决方案</td></tr><tr><td>Layabox</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>10</td><td>10</td><td>300K</td><td>-</td></tr><tr><td>Hilo</td><td>Yes</td><td><code>No</code></td><td>Yes</td><td><code>No</code></td><td>5</td><td><code>None</code></td><td>-</td><td>-</td></tr><tr><td>Cocos2d</td><td>Yes</td><td><code>No</code></td><td>Yes</td><td><code>No</code></td><td>7</td><td><code>None</code></td><td>-</td><td>-</td></tr></tbody></table><h4 id="展示型："><a href="#展示型：" class="headerlink" title="展示型："></a>展示型：</h4><h5 id="Lottie"><a href="#Lottie" class="headerlink" title="Lottie"></a><a href="http://airbnb.io/lottie" target="_blank" rel="noopener">Lottie</a></h5><p>1.官网：<a href="http://airbnb.io/lottie" target="_blank" rel="noopener">http://airbnb.io/lottie</a></p><p><strong>2.优点</strong>：跨平台（iOS|Android|Web|RN|windows）、开源、文件较小、api较完备…</p><p><strong>3.缺点</strong>：</p><ul><li>Bodymovin插件待完善，仍有部分AE效果无法成功导出</li><li>Lottie对json文件的支持待完善，仍有部分成功导出的json文件在移动端上无法很好的展现</li><li>交互支持不够友好</li></ul><p><strong>4.设计</strong>：<strong>AE</strong> + bodymovin</p><p>5.<a href="https://codepen.io/tag/lottie/" target="_blank" rel="noopener">demo</a></p><p><img src="//pic1.58cdn.com.cn/nowater/iblog/n_v27837621979da40a695e3fdf98c428267.gif"></p><h5 id="Svga"><a href="#Svga" class="headerlink" title="Svga"></a><a href="https://svga.io/" target="_blank" rel="noopener">Svga</a></h5><p>1.官网：<a href="https://svga.io/" target="_blank" rel="noopener">https://svga.io/</a></p><p><strong>2.优点</strong>：跨平台（iOS|Android|Web）兼容性好、开源、使用简单、性能卓越</p><p><strong>3.缺点</strong>：动画方式唯一、交互支持不够友好</p><p>4.设计：<strong>AE</strong> | Animate(Flash)</p><p>5.<a href="https://www.zcool.com.cn/work/ZNDAzMzQ2ODQ=.html" target="_blank" rel="noopener">demo</a></p><p><img src="//pic1.58cdn.com.cn/nowater/iblog/n_v27cc0d3a2886142c28711f6a398a0cb02.png"></p><h4 id="交互型："><a href="#交互型：" class="headerlink" title="交互型："></a>交互型：</h4><h5 id="Three-js"><a href="#Three-js" class="headerlink" title="Three.js"></a><a href="https://threejs.org/" target="_blank" rel="noopener">Three.js</a></h5><p>1.官网：<a href="https://threejs.org/" target="_blank" rel="noopener">https://threejs.org/</a></p><p>2.JS 语言的 3D 库</p><p>3.设计：3Dsmax（3dMax）、blender、Sketchup、maya、unity…</p><p>4.<a href="http://www.kt5.cn/3d-animes/" target="_blank" rel="noopener">3d动漫人物欣赏</a></p><p>5.Demo（3d模型、粒子化）</p><p><img src="//pic1.58cdn.com.cn/nowater/iblog/n_v299cadf6f7ac24fbaa6994c12c6eb9a1b.png"><br><img src="//pic1.58cdn.com.cn/nowater/iblog/n_v2bcd092b4e77b4a97ba49d971a0650a3d.png"></p><h5 id="Dragonbones"><a href="#Dragonbones" class="headerlink" title="Dragonbones"></a><a href="http://dragonbones.com/cn/index.html" target="_blank" rel="noopener">Dragonbones</a></h5><p>1.官网：<a href="http://dragonbones.com/cn/index.html" target="_blank" rel="noopener">http://dragonbones.com/cn/index.html</a></p><p>2.概念：2D骨骼动画解决方案（面向设计师的动画创作平台；更少的美术成本，更生动的动画效果；多语言支持，一次制作，全平台发布）</p><p>3.预设动画欣赏</p><p><img src="//pic1.58cdn.com.cn/nowater/iblog/n_v2ddaa8774bba14944b691b9680f41a1f4.png"></p><p>4.Demo（公鸡换装）</p><p><img src="//pic1.58cdn.com.cn/nowater/iblog/n_v2e15e6408408e45a09bfdb08d3d032912.gif"></p><h3 id="四、设计细节"><a href="#四、设计细节" class="headerlink" title="四、设计细节"></a>四、设计细节</h3><h4 id="常见3d文件格式："><a href="#常见3d文件格式：" class="headerlink" title="常见3d文件格式："></a>常见3d文件格式：</h4><p><img src="//pic1.58cdn.com.cn/nowater/iblog/n_v2b47e3ec0724c4f2895af806011b01700.png" alt="3d文件格式"></p><h4 id="官方推荐使用格式：gltf（glb）"><a href="#官方推荐使用格式：gltf（glb）" class="headerlink" title="官方推荐使用格式：gltf（glb）"></a>官方推荐使用格式：gltf（glb）</h4><h4 id="粒子化3D模型效果总结："><a href="#粒子化3D模型效果总结：" class="headerlink" title="粒子化3D模型效果总结："></a>粒子化3D模型效果总结：</h4><ul><li>建议模型：gltf/glb</li><li>注意点：模型不需要过于细节化，否则绘制粒子数量过大严重影响性能</li></ul><h4 id="骨骼动画总结（2D）："><a href="#骨骼动画总结（2D）：" class="headerlink" title="骨骼动画总结（2D）："></a>骨骼动画总结（2D）：</h4><ul><li>建议编辑器：Dragonbones（龙骨）</li><li>缺陷：拟3D效果，有一定角度限制</li><li>补足：如需要展示更多角度，需设计出更多角度的贴图</li></ul><h3 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h3><ol><li><a href="https://juejin.im/post/6844903655926153223" target="_blank" rel="noopener">前端动画调研</a></li><li><a href="https://juejin.im/post/6844903701736325133" target="_blank" rel="noopener">3D探索——Web 3D哪家强</a></li><li><a href="https://blog.csdn.net/weixin_33857230/article/details/91698283" target="_blank" rel="noopener">三维文件格式 abc, glTF, fbx, obj, dae, stl, 3ds, ply,…</a></li><li><a href="https://www.zhihu.com/question/268392246" target="_blank" rel="noopener">3d模型下载的哪个网站好</a></li><li><a href="https://blog.csdn.net/FlyPigYe/article/details/90267479" target="_blank" rel="noopener">白鹭引擎和layabox哪个好用，哪个技术更成熟</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前期曾细粒度的从多个角度对 web 动画做过一些研究，今天主要想从宏观的角度总结一下动画的实现以及目前主流的3D库。&lt;br&gt;在愈来愈追求极致体验的今天，Web开发者已经不满足于2D效果的实现，而把目标放到了更加炫酷的3D效果上。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="动画" scheme="//blog.zhiyuchangxin.cn/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>破除 Margin 的黑魔法</title>
    <link href="//blog.zhiyuchangxin.cn/articles/margin/index.html"/>
    <id>//blog.zhiyuchangxin.cn/articles/margin/index.html</id>
    <published>2019-01-09T06:30:00.000Z</published>
    <updated>2020-12-25T12:51:44.434Z</updated>
    
    <content type="html"><![CDATA[<p>Margin 真是个神奇的属性，使用过程中总能给我们带来各种惊喜。<br>这不，今天又掉进了他的大坑！我给<code>margin-top</code>设置的负值总是不生效。<br>越是着急用他的时候越是罢工，出现各种异常表现。拖延症晚期的我也终于忍无可忍，决心今天一定要彻底破除<code>margin</code>的黑魔法~</p><a id="more"></a><p>先从基础的开始吧，逐步的深入，希望通过这次机会我们能彻底驯服这只桀骜不驯的小兽。</p><h3 id="Margin-基础"><a href="#Margin-基础" class="headerlink" title="Margin 基础"></a>Margin 基础</h3><p>margin 是一个设置盒子模型外边距的属性，其值的大小不会像 padding 那样对元素本身的尺寸造成影响。<br>margin 可以设置的类型有以下四种（如表 1）：</p><div style="margin: 15px 0 -15px;">表1：margin 取值类型</div><table><thead><tr><th style="text-align:center">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">auto</td><td style="text-align:left">浏览器计算外边距</td></tr><tr><td style="text-align:center">length</td><td style="text-align:left">规定以具体单位计的外边距值，比如像素、厘米等。默认值是 0px</td></tr><tr><td style="text-align:center">%</td><td style="text-align:left">规定基于父元素的宽度的百分比的外边距</td></tr><tr><td style="text-align:center">inherit</td><td style="text-align:left">规定应该从父元素继承外边距</td></tr></tbody></table><p>需要注意以下两点：</p><ol><li>margin 值设置 % 时都是相对于元素的<strong>宽度</strong>计算的</li><li>margin 的默认值是 0，所以后面在使用 auto 时一定要手动设置</li></ol><h3 id="Margin-异常场景汇总"><a href="#Margin-异常场景汇总" class="headerlink" title="Margin 异常场景汇总"></a>Margin 异常场景汇总</h3><p>我最喜欢<code>margin-left</code>属性啦，它是真的乖，在任何场景下均无异常表现~<br>但是其他方向表现如何呢，下面我们通过<a href="//codepen.io/zhiyuchangxin/pen/OrwoPx" target="_blank"><code>DEMO1</code></a>进行实验，最终我对 margin 的各种情况验证并整理出表 2（可能不全，欢迎补充~）</p><blockquote><p>表 2 结论的前提条件有下面几点：<br>1.<code>margin-top</code>主要针对盒子中的第一个元素实验;<br>2.<code>margin-right</code>、<code>margin-bottom</code>主要针对盒子中最后一个元素实验；<br>3.「子」——子元素、「父」——父元素盒子；结论主要针对的是子元素的各种表现。</p></blockquote><div style="margin: 15px 0 -15px;">表2：margin 在不同场景下的表现</div><table><!--block--><thead><tr><th>「子」Display</th><th>「子」Margin</th><th>「子」取值符号</th><th>「父」定宽高</th><th>「父」inline-block<br>「子」表现</th><th>「父」block<br>「子」表现</th></tr></thead><tbody><tr><td rowspan="16">block</td><td rowspan="4">margin-top</td><td rowspan="2">+</td><td>Y</td><td>正常</td><td style="color: #71d6f5;">合并</td></tr><tr><td>N</td><td>正常</td><td style="color: #71d6f5;">合并</td></tr><tr><td rowspan="2">-</td><td>Y</td><td>正常</td><td style="color: #71d6f5;">合并</td></tr><tr><td>N</td><td>正常</td><td style="color: #71d6f5;">合并</td></tr><tr><td rowspan="4">margin-bottom</td><td rowspan="2">+</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td>正常</td><td style="color: #71d6f5;">合并</td></tr><tr><td rowspan="2">-</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td>正常</td><td style="color: #71d6f5;">合并</td></tr><tr><td rowspan="4">margin-left</td><td rowspan="2">+</td><td>Y</td><td>正常</td><td>正常</td></tr><tr><td>N</td><td>正常</td><td>正常</td></tr><tr><td rowspan="2">-</td><td>Y</td><td>正常</td><td>正常</td></tr><tr><td>N</td><td>正常</td><td>正常</td></tr><tr><td rowspan="4">margin-right</td><td rowspan="2">+</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td>正常</td><td style="color: #fabf51;">失效</td></tr><tr><td rowspan="2">-</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td>正常</td><td style="color: #fabf51;">失效</td></tr><!--inline--><tr><td rowspan="16">inline</td><td rowspan="4">margin-top</td><td rowspan="2">+</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td rowspan="2">-</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td rowspan="4">margin-bottom</td><td rowspan="2">+</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td rowspan="2">-</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td rowspan="4">margin-left</td><td rowspan="2">+</td><td>Y</td><td>正常</td><td>正常</td></tr><tr><td>N</td><td>正常</td><td>正常</td></tr><tr><td rowspan="2">-</td><td>Y</td><td>正常</td><td>正常</td></tr><tr><td>N</td><td>正常</td><td>正常</td></tr><tr><td rowspan="4">margin-right</td><td rowspan="2">+</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td>正常</td><td style="color: #fabf51;">失效</td></tr><tr><td rowspan="2">-</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td>正常</td><td style="color: #fabf51;">失效</td></tr><!--inline-block--><tr><td rowspan="16">inline-block</td><td rowspan="4">margin-top</td><td rowspan="2">+</td><td>Y</td><td>正常</td><td>正常</td></tr><tr><td>N</td><td>正常</td><td>正常</td></tr><tr><td rowspan="2">-</td><td>Y</td><td style="color: #f00;">失效</td><td style="color: #f00;">失效</td></tr><tr><td>N</td><td style="color: #f00;">失效</td><td style="color: #f00;">失效</td></tr><tr><td rowspan="4">margin-bottom</td><td rowspan="2">+</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td>正常</td><td>正常</td></tr><tr><td rowspan="2">-</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td>正常</td><td>正常</td></tr><tr><td rowspan="4">margin-left</td><td rowspan="2">+</td><td>Y</td><td>正常</td><td>正常</td></tr><tr><td>N</td><td>正常</td><td>正常</td></tr><tr><td rowspan="2">-</td><td>Y</td><td>正常</td><td>正常</td></tr><tr><td>N</td><td>正常</td><td>正常</td></tr><tr><td rowspan="4">margin-right</td><td rowspan="2">+</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td>正常</td><td style="color: #fabf51;">失效</td></tr><tr><td rowspan="2">-</td><td>Y</td><td style="color: #fabf51;">失效</td><td style="color: #fabf51;">失效</td></tr><tr><td>N</td><td>正常</td><td style="color: #fabf51;">失效</td></tr></tbody></table><p>表 2 中的异常表现，后面会给出相应的解决方案</p><h3 id="Margin-auto-剖析"><a href="#Margin-auto-剖析" class="headerlink" title="Margin: auto 剖析"></a>Margin: auto 剖析</h3><p><code>margin: auto</code> 是为了填充空闲尺寸而设计的。<br>听着有些抽象，具体怎么填充的呢？我们继续探索~</p><h4 id="margin-auto-的填充规则"><a href="#margin-auto-的填充规则" class="headerlink" title="margin: auto 的填充规则"></a>margin: auto 的填充规则</h4><ul><li>规则一：两侧均为 auto 时，平分剩余空间</li><li>规则二：一侧定值，一侧 auto 时，auto 为剩余空间大小</li></ul><h4 id="margin-auto-的水平布局"><a href="#margin-auto-的水平布局" class="headerlink" title="margin: auto 的水平布局"></a>margin: auto 的水平布局</h4><p>正因为<code>margin: auto</code> 两条填充规则的存在，使得<strong>块级元素</strong>实现了类似于<strong>行间元素</strong><code>text-aligin</code>水平布局的特性</p><ul><li>水平居中：使用“规则一”实现水平居中，这点我们再熟悉不过了，不再赘述。</li><li>水平居右：使用“规则二”实现水平居右，这点却经常会被我们忽视掉，快来看下<a href="//codepen.io/zhiyuchangxin/pen/EGddvy" target="_blank"><code>DEMO2</code></a>的实现</li></ul><p>没错，我们通过设置<code>margin-left:auto</code> 实现了水平居右，这样一来 <code>float:right</code> 也可以休息片刻啦~</p><h4 id="margin-auto-的垂直布局"><a href="#margin-auto-的垂直布局" class="headerlink" title="margin: auto 的垂直布局"></a>margin: auto 的垂直布局</h4><p>垂直布局？？？<br>在我的印象中貌似实现不了垂直布局，<a href="//codepen.io/zhiyuchangxin/pen/EGdMjv" target="_blank"><code>DEMO3</code></a>也验证了这一点：DEMO3 只实现了水平居中，未实现垂直居中。<br>为什么没实现垂直布局呢？想弄明白这一点，就要对“空闲尺寸”的“自动填充”做进一步的理解了。</p><p><code>margin: auto</code>触发的前提需要特别注意：</p><ul><li>水平触发：当<code>width</code>设为<code>auto</code>时，宽度能自动填充满容器</li><li>垂直触发：当<code>height</code>设为<code>auto</code>时，高度能自动填充满容器</li></ul><blockquote><p>DEMO3 中：当 .in 设置<code>width:auto</code>后可以自动填充为 .out 的宽度 400px，满足对应方向的自动填充规则；<br>但 .in 设置<code>height:auto</code>后却不能自动填充为 .out 的高度 300px，未能满足对应方向的自动填充规则。<br>所以只实现了水平方向的居中，不能实现垂直方向的居中。</p></blockquote><p>那如果我们一定要实现垂直方向居中（IE8+）又该如何做呢？</p><ol><li>经典三步曲：绝对定位 + 50%的 top 值 + height 一半的负值</li><li>新思路：绝对定位 + top:0 + bottom:0 + 垂直方向 margin:auto</li></ol><blockquote><p>因为当设置了绝对定位+top:0+bottom:0 后，即使将高度设置为 auto，依然能自动填充满屏高，所以满足 margin:auto 在垂直方向的触发条件^_^</p></blockquote><p>下面<a href="//codepen.io/zhiyuchangxin/pen/roogaQ" target="_blank"><code>DEMO4</code></a>展示了水平垂直居中的终极实现，这才应该是居中的正确打开方式。  </p><h3 id="Margin-合并现象"><a href="#Margin-合并现象" class="headerlink" title="Margin 合并现象"></a>Margin 合并现象</h3><p>根据表 2 的实验结果，我们抽离出 <code>margin</code> 合并的情况再做详细梳理。</p><blockquote><p>注：不考虑 <code>writing-mode</code> 的影响，我们这里所提的 <code>margin</code> 主要指<strong>垂直方向上的</strong>合并~</p></blockquote><h4 id="父子合并"><a href="#父子合并" class="headerlink" title="父子合并"></a>父子合并</h4><h5 id="异常表现："><a href="#异常表现：" class="headerlink" title="异常表现："></a>异常表现：</h5><ul><li>父元素与第一个子元素的 <code>margin-top</code> 的合并<ul><li>表 2 中：块级<code>block</code>「父元素」与「子元素」的 margin-top <strong><em>正负值均与父元素发生合并</em></strong></li></ul></li><li>父元素与最后一个子元素的 <code>margin-bottom</code> 的合并：<ul><li>表 2 中：块级<code>block</code>+未定高「父元素」与「子元素」的 margin-bottom <strong><em>正负值均与父元素发生合并</em></strong></li></ul></li></ul><h5 id="margin-top合并的解决方案："><a href="#margin-top合并的解决方案：" class="headerlink" title="margin-top合并的解决方案："></a><code>margin-top</code>合并的解决方案：</h5><ul><li>父元素触发 BFC</li><li>父元素设置<code>padding-top</code>值（非 0）</li><li>父元素设置<code>border-top</code>的值</li><li>首个子元素前添加内联元素（分隔异常父子）</li></ul><h5 id="margin-bottom合并的解决方案："><a href="#margin-bottom合并的解决方案：" class="headerlink" title="margin-bottom合并的解决方案："></a><code>margin-bottom</code>合并的解决方案：</h5><ul><li>父元素触发 BFC</li><li>父元素设置<code>padding-bottom</code>值（非 0）</li><li>父元素设置<code>border-bottom</code>的值</li><li>最后一个子元素后添加内联元素（分隔异常父子）</li></ul><p>触发 BFC 最常用的方案是添加下面属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>父子合并解决方案的实质：通过一定手段强行分隔开异常父子，避免其直接接触，如<code>padding</code>、<code>border</code>、其他内联元素等</p></blockquote><h4 id="相邻兄弟元素合并"><a href="#相邻兄弟元素合并" class="headerlink" title="相邻兄弟元素合并"></a>相邻兄弟元素合并</h4><p>此种现象对我们的布局影响不大，甚至有时这种合并会更方便我们的布局；<br>一定要处理这种合并的话，迫使某一元素触发 BFC 即可解决~</p><p>触发 BFC 最常用的方案同上添加：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure></p><h4 id="空块级元素合并"><a href="#空块级元素合并" class="headerlink" title="空块级元素合并"></a>空块级元素合并</h4><p>这种情形我们遇到的就更少啦，这种机制的存在本意就是为了防止有一些多余的空标签未删除对布局造成影响。<br>实际开发中多余空标签的存在是不规范的，直接删除就好!<br>要强行保留空标签并解决合并问题的话，方法也是类似：</p><ul><li>设置垂直方向<code>padding</code>的值（非 0）</li><li>设置垂直方向<code>border</code>的值</li><li>空标签中添加内容（直接添加 space 无效，用<code>&amp;nbsp;</code>代替）</li></ul><h3 id="Margin-无效场景解析"><a href="#Margin-无效场景解析" class="headerlink" title="Margin 无效场景解析"></a>Margin 无效场景解析</h3><h4 id="margin-无效场景总结"><a href="#margin-无效场景总结" class="headerlink" title="margin 无效场景总结"></a>margin 无效场景总结</h4><p>根据表 2 的实验结果，我们抽离出 <code>margin</code> 无效的情况再做详细梳理。</p><ol><li>行间<code>inline</code>元素的垂直 <code>margin</code> 均无效</li><li>行块<code>inline-block</code>元素的 <code>margin-top</code> 负值无效</li><li>定高容器的「子元素」的 <code>margin-bottom</code> 均无效</li><li>定宽容器/块级<code>block</code>未定宽容器的「子元素」的 <code>margin-right</code> 均无效</li><li>发生 <code>margin</code> 合并时，<code>margin</code> 垂直方向值小于合并后值时设置无效</li></ol><p>非表 2 中表现出的无效现象的补充：</p><ol><li>表格布局中的<code>&lt;tr&gt;</code>、<code>&lt;td&gt;</code>、<code>table-cell</code>、<code>table-row</code> 的 <code>margin</code> 无效</li><li>绝对定位元素非定位方向的 <code>margin</code> 无效</li></ol><h4 id="margin-无效场景解决方案"><a href="#margin-无效场景解决方案" class="headerlink" title="margin 无效场景解决方案"></a>margin 无效场景解决方案</h4><p>针对表 2 无效场景出现的对应顺序给出如下解决方案：</p><ol><li>行间<code>inline</code>元素设置为行块<code>inline-block</code>元素</li><li>行块<code>inline-block</code>元素设置 <code>vertical-align: !baseline</code> 非默认值（这里需要对 <code>vertical-align</code>做进一步深入）</li><li>容器不定高</li><li>容器设置为行块<code>inline-block</code>元素不定宽</li><li>解决<code>margin</code>合并问题</li></ol><h3 id="Margin-常用场景"><a href="#Margin-常用场景" class="headerlink" title="Margin 常用场景"></a>Margin 常用场景</h3><ul><li>垂直水平居中布局<a href="//codepen.io/zhiyuchangxin/pen/roogaQ" target="_blank"><code>DEMO4</code></a></li><li>两栏自适应布局<a href="//codepen.io/zhiyuchangxin/pen/ebbaMa" target="_blank"><code>DEMO5</code></a><ul><li>注意<code>margin-right</code>生效的前提是：盒子为行块<code>inline-block</code>元素不定宽</li></ul></li><li>两端对齐布局<a href="//codepen.io/zhiyuchangxin/pen/dwwxqB" target="_blank"><code>DEMO6</code></a></li><li>两栏等高布局<a href="//codepen.io/zhiyuchangxin/pen/ZVVgVo" target="_blank"><code>DEMO7</code></a></li></ul><blockquote><p>此处“两栏等高布局”实现的缺点：<br>1.没有底部边框，需手动添加（无需边框的场景比较方便）<br>2.父元素<code>overflow:hidden</code>对子元素有一定的局限性（子元素定位到容器之外的场景不适用）<br>3.影响锚点定位</p></blockquote><p>正是这些不足的存在督促我们继续探索 =&gt; 可进一步总结其他实现“两栏等高布局”的方案（后期补充~）</p><p>今天的总结就到这里，自己梳理的基础上希望也能给大家带来些帮助。<br>发现问题欢迎随时指出哟^_^</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>CSS 世界 —— 张鑫旭</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Margin 真是个神奇的属性，使用过程中总能给我们带来各种惊喜。&lt;br&gt;这不，今天又掉进了他的大坑！我给&lt;code&gt;margin-top&lt;/code&gt;设置的负值总是不生效。&lt;br&gt;越是着急用他的时候越是罢工，出现各种异常表现。拖延症晚期的我也终于忍无可忍，决心今天一定要彻底破除&lt;code&gt;margin&lt;/code&gt;的黑魔法~&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="//blog.zhiyuchangxin.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>谁还没遇上“层叠上下文”呢</title>
    <link href="//blog.zhiyuchangxin.cn/articles/StackingContext/index.html"/>
    <id>//blog.zhiyuchangxin.cn/articles/StackingContext/index.html</id>
    <published>2018-09-10T07:00:00.000Z</published>
    <updated>2019-01-18T09:41:54.450Z</updated>
    
    <content type="html"><![CDATA[<p>一晃时间走了好远，又一年教师节了，在此祝所有老师教师节快乐！<br>言归正传，为何提笔写此文呢？前两天在项目中给某个节点A设置 fixed 定位后出现了一个神奇的现象：无论我怎么设置其子节点B的层级，B总是会被A之后出现的带有层级的元素节点遮挡。<br>我仿佛发现了新大陆一般惊奇，平日里对待熟悉的事物我总能做到恰到好处的蜻蜓点水，终于掉坑里了吧(囧)。于是乎，我决定今天要彻底弄懂层叠上下文（Stacking Context）。</p><a id="more"></a><p>还是先来看一下我遇到的问题吧~<br>分别用<strong><code>chrome/firefox</code></strong>和<strong><code>IE</code></strong>打开<a href="//codepen.io/zhiyuchangxin/pen/LXNLRb" target="_blank"><code>DEMO1</code></a></p><p><img src="//cdn.zhiyuchangxin.cn/stack-noie.png?imageMogr2/thumbnail/400x/blur/1x0/quality/75|watermark/2/text/QOe7h-ivremVv-W_gw==/font/5a6L5L2T/fontsize/240/fill/I0UxRTFFMQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="非IE浏览器" title="非IE浏览器"></p><p><img src="//cdn.zhiyuchangxin.cn/stack-ie.png?imageMogr2/thumbnail/400x/blur/1x0/quality/75|watermark/2/text/QOe7h-ivremVv-W_gw==/font/5a6L5L2T/fontsize/240/fill/I0UxRTFFMQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="IE浏览器" title="IE浏览器"></p><p>哇~为什么IE上的表现和我们的预期一致，而 chrome/firefox 上却出现了异常呢？<br>如果你也跟我一样好奇，那咱们就快点开始这次旅行吧~</p><blockquote><p>文中所有 IE 浏览器除特殊标明包含 IE7 外 均指 IE7 以上</p></blockquote><h3 id="一、层叠界的术语"><a href="#一、层叠界的术语" class="headerlink" title="一、层叠界的术语"></a>一、层叠界的术语</h3><ol><li><strong>Z轴</strong>：眼睛垂直于屏幕的一条虚拟的轴线</li><li><strong>层叠上下文(Stacking Context)</strong>：表示元素在z轴上的层叠水平（<code>html</code>的三维概念）</li><li><strong>层叠顺序(Stacking Order)</strong>：表示同一层叠上下文中的元素在z轴上的显示顺序</li></ol><blockquote><p>重要的事说三遍：<br>所有层叠水平的比较都是以<strong>同一层叠上下文</strong>为基础的哟~<br><strong>同一层叠上下文</strong>为基础的哟~<br><strong>同一层叠上下文</strong>~</p></blockquote><h3 id="二、层叠准则（前提：同一层叠上下文中做比较）"><a href="#二、层叠准则（前提：同一层叠上下文中做比较）" class="headerlink" title="二、层叠准则（前提：同一层叠上下文中做比较）"></a>二、层叠准则（前提：同一层叠上下文中做比较）</h3><ol><li><strong>谁大谁上</strong>：非同一层叠水平时，水平高的在上面</li><li><strong>后来居上</strong>：同一层叠水平时，后出现的在上面</li></ol><h3 id="三、层叠上下文的特性"><a href="#三、层叠上下文的特性" class="headerlink" title="三、层叠上下文的特性"></a>三、层叠上下文的特性</h3><ol><li><strong>层叠上下文</strong>的层叠水平要比<strong>普通元素</strong>高</li><li>层叠上下文可以<strong><em>嵌套</em></strong>：内部层叠上下文及其所有子元素均受制于外部的层叠上下文</li><li>每个层叠上下文和兄弟元素<strong><em>独立</em></strong>：当进行层叠变化或渲染的时候，只需考虑后代元素</li><li>每个层叠上下文<strong><em>自成体系</em></strong>：当元素发生层叠的时候，整个元素被认为在<strong><em>父层叠上下文的层叠顺序中</em></strong></li><li>层叠上下文可以<strong><em>阻断</em></strong>元素的混合模式</li></ol><h3 id="四、层叠上下文的创建"><a href="#四、层叠上下文的创建" class="headerlink" title="四、层叠上下文的创建"></a>四、层叠上下文的创建</h3><ol><li><strong>天生派(根元素)</strong>：页面的根元素<code>&lt;html&gt;</code>天生具有层叠上下文</li><li><strong>正统派(传统)</strong>：<code>z-index</code>为<strong>数值</strong>的<strong>定位/布局元素</strong><ul><li>IE7 定位/布局元素直接生成层叠上下文，因为IE7的<code>z-index</code>默认值就是<code>0</code></li></ul></li><li><strong>扩招派(新秀)</strong>：<strong>CSS3</strong> 属性产生的层叠上下文</li></ol><h4 id="正统派层叠上下文创建"><a href="#正统派层叠上下文创建" class="headerlink" title="正统派层叠上下文创建"></a>正统派层叠上下文创建</h4><ol><li><strong><em><code>position: relative/absolute</code></em></strong>定位：<ul><li><code>z-index: !auto</code> 创建</li></ul></li><li><strong><em><code>position: fixed</code></em></strong>定位：<ul><li>「IE 内核的浏览器」<code>z-index: !auto</code> 创建</li><li>非「IE 内核的浏览器」直接创建（这就是 DEMO1 中异常现象产生的根源）</li></ul></li><li><strong><em><code>position: sticky</code></em></strong>定位时 ？？？<ul><li>sticky定位根据当前定位状态综合1，2两种情况</li></ul></li></ol><h4 id="扩招派层叠上下文创建"><a href="#扩招派层叠上下文创建" class="headerlink" title="扩招派层叠上下文创建"></a>扩招派层叠上下文创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">display:flex|inline-flex 弹性布局的元素：其”子元素“z-index != auto 创建</span><br><span class="line">元素的 opacity: !1</span><br><span class="line">元素的 transform: !none</span><br><span class="line">元素的 perspective != none // 透视效果</span><br><span class="line">元素的 filter: !none</span><br><span class="line">元素的 mix-blend-mode: !normal // 元素和白色背景混合，IE 不支持</span><br><span class="line">元素的 isolation: isolate // 阻隔混合模式</span><br><span class="line">元素的 will-change 属性值为 transform... // 增强页面渲染性能</span><br><span class="line">元素的 -webkit-overflow-scrolling: touch</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>层叠的表现可以看<a href="//codepen.io/zhiyuchangxin/pen/YRqxXO" target="_blank"><code>DEMO2</code></a></p><h3 id="五、层叠顺序（Stacking-Order）"><a href="#五、层叠顺序（Stacking-Order）" class="headerlink" title="五、层叠顺序（Stacking Order）"></a>五、层叠顺序（Stacking Order）</h3><p>顾名思义，层叠顺序即元素在 Z 轴上的显示顺序。<br>参照了张鑫旭对层叠顺序的图解，加之自己理解后，重新绘制了<strong><code>同一层叠上下文</code></strong>前提下的<strong><code>9级层叠顺序图</code></strong>，如下：<br><a href="//codepen.io/zhiyuchangxin/pen/RqarRv" target="_blank"><code>DEMO3</code></a></p><p><img src="//cdn.zhiyuchangxin.cn/stacking-order1.png?imageMogr2/thumbnail/650x/blur/1x0/quality/75|watermark/2/text/QOe7h-ivremVv-W_gw==/font/5a6L5L2T/fontsize/240/fill/I0UxRTFFMQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="层叠顺序" title="层叠顺序示意图"></p><blockquote><p>DEMO3 是我对9级层叠顺序图进行的校验，如过大家发现存在什么问题可以随时联系我~</p></blockquote><h4 id="思考两个问题"><a href="#思考两个问题" class="headerlink" title="思考两个问题"></a>思考两个问题</h4><ol><li>为什么内联元素（第6级）的层叠顺序比浮动元素（第5级）和块状元素（第4级）高？<ul><li>因为最初的最初我们所做的所有工作都是为展示图文信息做准备的，后来的诸多变化也未曾脱离这个源头</li></ul></li><li>为什么定位元素会在普通元素之上展示？<ul><li>从图中可见定位元素跑到了第7级水平，高于普通元素</li></ul></li></ol><h4 id="看图划重点啦："><a href="#看图划重点啦：" class="headerlink" title="看图划重点啦："></a>看图划重点啦：</h4><ol><li>当父级元素未生成自己的层叠上下文时，只需给<code>z-index</code>设置为负值即可实现元素的隐藏；</li><li>单纯从<strong>层叠水平</strong>来看，<code>z-index</code>的血统比其他方式生成层叠上下文的血统更纯正些；<ul><li>因为<code>z-index</code>除了设置为<code>auto/0</code>（与其他层叠上下文同级）外，还可以显性的设置大于 0 的值</li></ul></li><li>当<code>transform: translateZ(&gt;0)</code>出现后，<code>z-index</code>再想超越其层级就有些难度啦；<ul><li>由上图可见<code>transform: translateZ(&gt;0)</code>在最高级了</li></ul></li><li>虽有难度，但依然可以超越。只需给<code>非body</code>祖先元素添加<code>overflow:hidden</code>样式<code>z-index</code>就能重拾老大的称号~<ul><li>这是因为当给<code>非body</code>祖先元素添加了<code>overflow:hidden</code>后，<code>transform</code>便失去了其独特的魔法，此时的它乖乖地回到了第7级水平。</li></ul></li></ol><p><a href="//codepen.io/zhiyuchangxin/pen/RqarRv" target="_blank"><code>DEMO3</code></a>给<code>.bg-box 添加 overflow: hidden;</code>可以验证一下第四点</p><h3 id="六、改变层叠顺序"><a href="#六、改变层叠顺序" class="headerlink" title="六、改变层叠顺序"></a>六、改变层叠顺序</h3><h4 id="不产生层叠上下文的前提下："><a href="#不产生层叠上下文的前提下：" class="headerlink" title="不产生层叠上下文的前提下："></a>不产生层叠上下文的前提下：</h4><h5 id="1-调整DOM结构"><a href="#1-调整DOM结构" class="headerlink" title="(1) 调整DOM结构"></a>(1) 调整<code>DOM</code>结构</h5><ul><li>后来居上准则</li></ul><h5 id="2-添加非z-index相关的属性"><a href="#2-添加非z-index相关的属性" class="headerlink" title="(2) 添加非z-index相关的属性"></a>(2) 添加<code>非z-index</code>相关的属性</h5><ul><li>block、float、inline、inline-block、定位…</li></ul><h4 id="产生层叠上下文的前提下："><a href="#产生层叠上下文的前提下：" class="headerlink" title="产生层叠上下文的前提下："></a>产生层叠上下文的前提下：</h4><h5 id="1-z-index问鼎天下"><a href="#1-z-index问鼎天下" class="headerlink" title="(1) z-index问鼎天下"></a>(1) <code>z-index</code>问鼎天下</h5><ul><li><code>z-index</code>设置层级须在定位元素<code>position:!static</code>或父元素弹性布局<code>display:flex</code>时生效，其值越大层叠水平越高；</li><li><strong>非IE7</strong>的定位元素默认添加<code>z-index:auto</code>属性；<a href="//codepen.io/zhiyuchangxin/pen/MqrNJJ" target="_blank"><code>DEMO4</code></a></li></ul><p><img src="//cdn.zhiyuchangxin.cn/fixed-before.gif?imageMogr2/thumbnail/300x/blur/1x0/quality/75|watermark/2/text/QOe7h-ivremVv-W_gw==/font/5a6L5L2T/fontsize/240/fill/I0UxRTFFMQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="设置fixed" title="fixed 的兄弟元素未设置定位(position=static)"></p><p><img src="//cdn.zhiyuchangxin.cn/fixed-after.gif?imageMogr2/thumbnail/300x/blur/1x0/quality/75|watermark/2/text/QOe7h-ivremVv-W_gw==/font/5a6L5L2T/fontsize/240/fill/I0UxRTFFMQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="设置fixed" title="fixed 的兄弟元素设置定位(eg: position=relative)"></p><blockquote><p>现象：我们给 fixed 的相邻兄弟元素添加了 position: relative 后再滚动页面，发现 fixed 元素被遮住了！！！<br>原因：同时设置定位后，元素均处于层叠顺序的第7级，处于同一层叠水平上，加之“后来居上”准则得此结果。</p></blockquote><ul><li><strong>IE7</strong>的定位元素默认添加<code>z-index:0</code>属性，直接创建层叠上下文；</li><li><code>z-index:auto</code>与<code>z-index:0</code>在层叠顺序上均属于第7级，但在层叠上下文的产生上差异很大；</li><li><code>position:fixed</code>在<strong>非IE</strong>浏览器中会直接生成层叠上下文，无需显性设置<code>z-index</code>为数值；</li></ul><h5 id="2-translateZ逐鹿中原"><a href="#2-translateZ逐鹿中原" class="headerlink" title="(2) translateZ逐鹿中原"></a>(2) <code>translateZ</code>逐鹿中原</h5><ul><li><code>transform</code> 可生成新的层叠上下文<br><img src="//cdn.zhiyuchangxin.cn/transforem-after.gif?imageMogr2/thumbnail/300x/blur/1x0/quality/75|watermark/2/text/QOe7h-ivremVv-W_gw==/font/5a6L5L2T/fontsize/240/fill/I0UxRTFFMQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="translateY 生成了新的层叠上下文" title="translateY 生成了新的层叠上下文"><blockquote><p>现象：下拉刷新的logo设置translateY偏移量后，结束刷新时logo没有被遮住；<br>原因：<code>transform</code> 可生成新的层叠上下文。</p></blockquote></li><li>通过设置 translateZ 的值来改变元素的层叠水平，其值越大，层级越高</li><li>translateZ 改变层级需要满足下列条件<strong>之一</strong>：<ul><li>父元素中设置 transform-style: preserve-3d</li><li>当前元素设置 perspective 透视<br><img src="//cdn.zhiyuchangxin.cn/transform-before.gif?imageMogr2/thumbnail/300x/blur/1x0/quality/75|watermark/2/text/QOe7h-ivremVv-W_gw==/font/5a6L5L2T/fontsize/240/fill/I0UxRTFFMQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="translateZ 处理后" title="translateZ 处理后"></li></ul></li></ul><h5 id="3-z-index与translateZ双剑合璧？？？"><a href="#3-z-index与translateZ双剑合璧？？？" class="headerlink" title="(3) z-index与translateZ双剑合璧？？？"></a>(3) <code>z-index</code>与<code>translateZ</code>双剑合璧？？？</h5><p>当我们同时设置<code>transform</code>与<code>z-index</code>时，常会出现<code>z-index</code>失效的情况<br><img src="//cdn.zhiyuchangxin.cn/transform-zindex0.png?imageMogr2/thumbnail/400x/blur/1x0/quality/75|watermark/2/text/QOe7h-ivremVv-W_gw==/font/5a6L5L2T/fontsize/240/fill/I0UxRTFFMQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="层叠冲突" title="transform与z-index冲突"></p><p>我们该如何解决上述冲突呢？</p><ul><li>任意<code>非body</code>祖先元素设置<code>overflow:hidden</code>即可恢复和其他浏览器一样的渲染</li></ul><p><img src="//cdn.zhiyuchangxin.cn/transform-zindex.gif?imageMogr2/thumbnail/600x/blur/1x0/quality/75|watermark/2/text/QOe7h-ivremVv-W_gw==/font/5a6L5L2T/fontsize/240/fill/I0UxRTFFMQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="解决层叠冲突" title="解决层叠冲突之非body祖先元素设置 overflow:hidden"></p><ul><li>以毒攻毒：同样可以使用 3D transform 变换</li><li>使劲提高 translateZ 的值（对于透视的情况，临界值并不好掌握-_-）</li></ul><h3 id="七、代码中的规范"><a href="#七、代码中的规范" class="headerlink" title="七、代码中的规范"></a>七、代码中的规范</h3><ol><li>非浮动元素：z-index “不犯2”准则<ul><li>即对于非浮动元素 z-index 值的设置一般不超过 2</li></ul></li><li>浮层元素：z-index “层级计数器”<ul><li>对于浮层元素设置层级时，获取z-index最大值 / z-index默认值(习惯设置为9)</li></ul></li></ol><blockquote><p>重新解释 DEMO1：<br>非IE浏览器中，父元素设置 position:fixed 生成了层叠上下文；<br>此层叠上下文的产生破坏了”同一层叠上下文“中比较层叠水平的基础，导致子元素所有的层级设置都受到父级层叠上下文的限制；<br>最终造成的错觉是子元素的所有层级设置都失效了~</p></blockquote><h3 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h3><ol><li><a href="//www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/comment-page-1/#comment-386780">深入理解CSS中的层叠上下文和层叠顺序</a></li><li><a href="//www.cnblogs.com/reaf/p/5788781.html">z-index和transform,你真的了解吗？</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一晃时间走了好远，又一年教师节了，在此祝所有老师教师节快乐！&lt;br&gt;言归正传，为何提笔写此文呢？前两天在项目中给某个节点A设置 fixed 定位后出现了一个神奇的现象：无论我怎么设置其子节点B的层级，B总是会被A之后出现的带有层级的元素节点遮挡。&lt;br&gt;我仿佛发现了新大陆一般惊奇，平日里对待熟悉的事物我总能做到恰到好处的蜻蜓点水，终于掉坑里了吧(囧)。于是乎，我决定今天要彻底弄懂层叠上下文（Stacking Context）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="//blog.zhiyuchangxin.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>2017 年终总结</title>
    <link href="//blog.zhiyuchangxin.cn/articles/first/index.html"/>
    <id>//blog.zhiyuchangxin.cn/articles/first/index.html</id>
    <published>2018-01-18T14:08:00.000Z</published>
    <updated>2019-01-18T09:07:22.683Z</updated>
    
    <content type="html"><![CDATA[<p>2018 就这样悄悄地的来了，是我忽略了太多的征兆吗，现在才感觉到它的气息，亏欠了 2017 的那个句点，是时候该画上了。<br>2017，特别又特别的一年。这一年的北京微露清纯，少了雾霾的困扰，呈现出更加优雅的姿态；这一年的我稍显庞杂，没了学校的庇护，流露出略微复杂的心情；这一年的北京异常寒冷，这一年的我尤为忙碌；奈何此去无雪，向来经年有“学”。没控制住，文艺病又犯病了，那通俗点吧，这一年也许成长的不太明显，但我知道这是必经的旅行。</p><a id="more"></a><h3 id="2017-回眸一笑"><a href="#2017-回眸一笑" class="headerlink" title="2017 回眸一笑"></a>2017 回眸一笑</h3><p>17 年，我的既定目标是：在项目中提升自身的能力，努力脱掉前端小白的称号，最好能够折腾出一些有趣的东西。接近尾声了，只能说还算顺利的完成了前半段的计划——在项目中提升自己，至于后半段路——有意义的东西还没见踪影，需要继续加油啦。</p><h4 id="17-年的工作情况："><a href="#17-年的工作情况：" class="headerlink" title="17 年的工作情况："></a>17 年的工作情况：</h4><ol><li><strong>web 端项目：</strong>年初参与了组内第一个使用 vue 开发的 web 端项目。当时的我只是纯粹的写写业务，对于接口文档、项目配置、路由跳转等并未做深入的研究。之后 web 端项目接触的也越来越少。</li><li><strong>H5 项目：</strong>3/4 的时间都在做 H5 应用，独立承担的 H5 应用大概有七个。<ul><li>初期：使用 vue1 进行研发。对于技术，慢慢的由不熟悉到熟悉，经过一两个项目的洗礼后开始独立承担项目。</li><li>后期：随着 vue2 发布并日趋成熟，开始尝试使用 vue2 进行开发，vue2 项目换用了组内开发的组件库，很遗憾自己没有参与到组件的研发过程中去 :(</li></ul></li><li><strong>其他：</strong>穿插着切图、网站研发等其他任务</li></ol><h4 id="17-年的学习成果："><a href="#17-年的学习成果：" class="headerlink" title="17 年的学习成果："></a>17 年的学习成果：</h4><p>这一年主要还是在开发过程中成长，遇到问题查阅文档，逛社区、论坛，或者同小伙伴交流，寻找思路。业余时间太少，总结做的还不到位，只能展示出项目中用到的技术了。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">技术</th><th style="text-align:left">优劣分析</th><th style="text-align:center">掌握程度</th></tr></thead><tbody><tr><td style="text-align:center">切图</td><td style="text-align:left">Html5、Css3、JS、Jquery…</td><td style="text-align:left">Css3 掌握的稍微好一些</td><td style="text-align:center">★★★★★</td></tr><tr><td style="text-align:center">网站研发</td><td style="text-align:left">Html、Css、JS、Jquery、Freemarker、Java…</td><td style="text-align:left">Java 仅做了解</td><td style="text-align:center">★★★★☆</td></tr><tr><td style="text-align:center">vue1</td><td style="text-align:left">vue、vue-router、vue-resource、webpack、ES6…</td><td style="text-align:left">熟练掌握 vue1，掌握 webpack、ES6</td><td style="text-align:center">★★★★☆</td></tr><tr><td style="text-align:center">vue2</td><td style="text-align:left">vue、vuex、vue-router、webpack、ES6…</td><td style="text-align:left">熟练掌握 vue2，掌握 webpack、ES6</td><td style="text-align:center">★★★★☆</td></tr></tbody></table><h4 id="17-年的生活状态："><a href="#17-年的生活状态：" class="headerlink" title="17 年的生活状态："></a>17 年的生活状态：</h4><p>有一群志同道合的小伙伴，闲暇之余能聚在一起聊聊技术、谈谈理想，很开心、很珍惜。曾一度嚷嚷着要成立一个翻译小分队，专门翻译感觉不错的外文文献来着，最终搁浅了吧（囧），新的一年希望还能搭上我们的“翻译号”，真的扬帆<del>去流浪</del>哟！</p><p>有几个爱念叨却很仗义的闺蜜，有一个默默给与温暖与支持的伴侣，有一间面积很大的屋子（虽然是租的），感觉再养一只小萨摩生活就完美了。</p><blockquote><p>回首向来萧瑟处，归去，也无风雨也无晴。</p></blockquote><p>哈哈，苏轼乱入一下，确实很喜欢这种态度。马不停蹄的工作了一年，进步还是有的，但少了总结与深入学习的时间，收获跟预期还有些许差距，需要继续努力啦。</p><h3 id="2018-翘首以待"><a href="#2018-翘首以待" class="headerlink" title="2018 翘首以待"></a>2018 翘首以待</h3><p>首先想说，不管工作多忙，都要给自己预留时间做好总结，这是需要一定的技术支持和抗压能力的。能在拓宽广度的同时挖掘事物的深度，让一切变得通透明了，这样才能给自己更大的提升空间。<br>其次呢，更要学会抽离自己，超出工作本身去做一些令自己欣喜的事情。比如学习之余写写博文，比如让我们的“翻译号”再次扬帆，比如在 github 上做一些有趣的东西，比如静下心来练练书法……只有自己的眼光变得足够开阔了，才能装得下更美好的风景。</p><p>希望有一天我的脑袋能变得像“哆啦A梦”的万能口袋那样，什么新奇美好的东西都装得下，作一程序媛如此，我也就满意啦！</p><p><img src="//cdn.zhiyuchangxin.cn/doraemon.png" alt="机器猫" title="哆啦A梦"></p><p>打个小广告，这是我养的一只<a href="//github.com/zhiyuchangxin/doraemon">哆啦A梦</a>哟，想见它吗，快点点看!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 就这样悄悄地的来了，是我忽略了太多的征兆吗，现在才感觉到它的气息，亏欠了 2017 的那个句点，是时候该画上了。&lt;br&gt;2017，特别又特别的一年。这一年的北京微露清纯，少了雾霾的困扰，呈现出更加优雅的姿态；这一年的我稍显庞杂，没了学校的庇护，流露出略微复杂的心情；这一年的北京异常寒冷，这一年的我尤为忙碌；奈何此去无雪，向来经年有“学”。没控制住，文艺病又犯病了，那通俗点吧，这一年也许成长的不太明显，但我知道这是必经的旅行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="thinking" scheme="//blog.zhiyuchangxin.cn/tags/thinking/"/>
    
  </entry>
  
</feed>
